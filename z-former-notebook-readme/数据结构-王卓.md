# 数据结构两个层次

## 逻辑结构

- 描述数据元素之间的逻辑关系
- 与数据的存储无关，独立于计算机
- 是从具体问题抽象出来的数学模型

### 逻辑结构的种类

#### 划分方法一：

**（1）线性结构**

1 : 1）有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。

例如：线性表、栈、队列、串

**（2）非线性结构**

1 : n / m : n）一个结点可能有多个直接前趋和直接后继

例如：树、图

#### 划分方法二：

四种基本逻辑结构

1. **集合结构**：结构中的数据元素之间除了**同属于一个集合**的关系外，无任何其他关系。
2. **线性结构**：结构中的数据元素之间存在着**一对一**的线性关系
3. **树形结构**：结构中的数据元素之间存在着**一对多**的层次关系
4. **图状结构/网状结构**：结构中的数据元素之间存在着**多对多**的任意关系

## 存储结构（物理结构）

- 数据元素及其关系在计算机存储器中的结构（存储方式）
- 是数据结构在计算机中的表示

### 存储结构的种类

四种基本的存储结构：

- 顺序存储结构：
  - 用一组**连续**的存储单**依次**存储数据元素，数据元素之间的逻辑关系由元素的**存储位置**来表示。
  - C语言中用数组来实现顺序存储结构
- 链式存储结构
  - 用一组**任意**的存储单元存储数据元素，数据元素之间的逻辑关系用**指针**来表示。
  - C语言中用指针来实现链式存储结构
- 索引存储结构
  - 在存储结点信息的同时，还建立附加的**索引表（index）**。
  - 索号表中的每一项称为一个**索引项**，
  - 索引项的**一般形式**是：**（关键字，地址)**
  - 关键字是能**唯一标识**一个结点的那些数据项。
  - 若每个结点在索引表中都有一个索引项，则该索引表称之为**稠密索引(Dense Index)**。若一组结点在索引表中只对应一个索引项，则该索引表称之为**稀疏索引(Sparse Index)**
- 散列存储结构
  - 根据结点的**关键字**直接计算出该结点的存储地址





## 逻辑结构与存储结构的关系

- 存储结构是逻辑关系的映象与元素本身的映象。
- 逻辑结构是数据结构的抽象，存储结构是数据结构的实现
- 两者综合起来建立了数据元素之间的结构关系





# 抽象数据类型

![image-20230926150434527](D:\File\markdownPictures\image-20230926150434527.png)



# 概念小结

![image-20230926152101055](D:\File\markdownPictures\image-20230926152101055.png)





# 算法分析

- 一个好的算法首先要具备正确性，然后是健壮性，可读任，在几个方面都满足的情况下，主要考虑**算法的效率**，通过算法的效率高低来评判不同算法的优劣程度。

- 算法效率以下两个方面来考虑：

  **1.时间效率：**指的是算法所耗费的**时间**

  **2.空间效率**：指的是算法执行过程中所耗费的**存储空间**

- **时间效率和空间效率有时候是矛盾的。**



## 算法时间效率的度量

- 算法时间效率可以用依据该算法编制的程序在计算机上执行**所消耗的时间**来度量。
- 两种度量方法：
  - 事后统计：将算法实现，测算其时间和空间开销
  - 事前分析：对算法所消耗资源的一种估算方法

### 事前分析方法：

- 一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的**时间**与算法中进行的简单操作**次数乘积**。

  **算法运行时间 = 一个简单操作所需的时间 × 简单操作次数**

- 也即算法中每条语句的执行时间之和

  **算法运行时间 = ∑每条语句的执行次数 × 该语句执行一次所需的时间**

  - 每条语句的执行次数：语句频度

  **算法运行时间 = ∑每条语句频度 × 该语句执行一次所需的时间**

  - 每条语句执行一次所需的时间，一般是随机器而异的。

  - 取决于机器的指令性能、速度以及编译的代码质量。

  - 是由机器本身软硬件环境决定的，它与算法无关。
  - 所以，我们可假设执行每条语句所需的时间均为**单位时间**。此时对算
    法的运行时间的讨论就可转化为讨论该算法中所有语句的执行次数，即
    频度之和了。
  - 这就可以独立于不同机器的软硬件环境来分析算法的时间性能了。



**例如：两个 n*n 矩阵相乘的算法可以描述为：**

![image-20230926174534343](D:\File\markdownPictures\image-20230926174534343.png)

- 我们把算法所耗费的时间定文为该算法中每条语句的频度之和，

  则上述算法的时间消耗T(n)为：T(n) = 2n³+3n²+2n+1    **——————这是一个关于n的函数**

- 为了便于比较不同算法的时间效率，我们仅比较他们的数量级

  例如：两个不同的算法，时间消耗分别是：

  ​	**T1(n) = 10n²**		与		**T2(n) = 5n³**

- 若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/f(n)的极限值为**不等于零的常数**，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n))为**算法的渐进时间复杂度**(O是数量级的符号)，简称**时间复杂度**。



算法中基本语句重复执行的次数是问题规模n的某个函数f(n)，

算法的时间度量记作：T(n) = O(f(n))

**n越大算法的执行时间越长**

- 排序：n为记录数
- 矩阵：n为矩阵的阶数
- 多项式：n为多项式的项数
- 集合：n为元素个数
- 树：n为树的结点个数
- 图：n为图的顶点数或边数

![image-20230926182740369](D:\File\markdownPictures\image-20230926182740369.png)

![image-20230926183137132](D:\File\markdownPictures\image-20230926183137132.png)

![image-20230926183459249](D:\File\markdownPictures\image-20230926183459249.png)



![image-20230926183754845](D:\File\markdownPictures\image-20230926183754845.png)



![image-20230926184132834](D:\File\markdownPictures\image-20230926184132834.png)





## 渐进空间复杂度

**空间复杂度：**算法所需存储空间的度量

记作：S(n) = O(f(n))

n为问题的规模（或大小）

**算法要占用的空间：**

- 算法本身占用的空间，输入/输出，指令，常数，变量等
- 算法要使用的**辅助空间**



# 线性表

## 顺序表

------------------------

|   1   |   2   |   3   |   4   |   5   |

**是**一个典型的**线性表顺序存储结构**：依次存储，地址连续，没有空出存储单元

|   1   |      |      |   3   |   4   |

**不是**一个**线性表顺序存储结构**：地址不连续，中间存在空的存储单元

-----------------------------

**线性表顺序存储结构**占用一片连续的存储空间，知道某个元素的位置就可以计算其他元素的存储位置。

**顺序表的优点：**以物理位置相邻表示逻辑关系，任一元素均可随机存取。



**数组静态分配**

```c
typedef struct{
	ElemType data[MaxSize];
	int length;
}SqList;	//顺序表类型
```



如上存储的是data[0]的地址，如下*data也是第一个元素的地址。



**数组动态分配**

```c
typedef struct{
	ElemType *data;
	int length;
}SqList;	//顺序表类型
```

```C
SqList L;
L.data=(ElemType*)malloc(sizeof(ElemType)*MaxSize);
```



**内存分配函数**

- **malloc(m)函数，**开辟m字节长度的地址空间，并返回这段空间的首地址
- **sizeof(x)运算，**计算变量x的长度
- **free(p)函数，**释放指针p所指变量的存储空间，即彻底删除一个变量

**需要加载头文件：<stdlib.h>**



## 链式表

顺序表：存储地址+存储状态

链表：存储地址+节点（数据域+指针域）

<img src="D:\File\markdownPictures\image-20231010153240317.png" alt="image-20231010153240317" style="zoom:33%;float:left" />

<img src="D:\File\markdownPictures\image-20231010153302910.png" alt="image-20231010153302910" style="zoom:33%;float:left" />

单链表是由头指针唯一确定，因此单链表可以用头指针的名字来命名

例如上方图片的头指针为H，因此是单链表H

### 专业术语

**结点：**数据元素的存储映像。由数据域和指针域两部分组成

<img src="D:\File\markdownPictures\image-20231010153927861.png" alt="image-20231010153927861" style="zoom:33%;float:left" />

**链表：**n个结点由**指针链**组成一个链表

​	 他是线性表的链式存储映像，称为线性表的链式存储结构

​	<img src="D:\File\markdownPictures\image-20231010154127651.png" alt="image-20231010154127651" style="zoom:33%;float:left;margin-left:5%" />















### 单链表、双链表、循环链表：

- 结点只有一个指针域的链表，称为**单链表**或**线性链表**

  <img src="D:\File\markdownPictures\image-20231010154509103.png" alt="image-20231010154509103" style="zoom:33%" />

- 结点有两个指针域的链表，称为**双链表**

  <img src="D:\File\markdownPictures\image-20231010154907152.png" alt="image-20231010154907152" style="zoom:33%;" />

- 首尾相接的链表称为**循环链表**

  <img src="D:\File\markdownPictures\image-20231010155128568.png" alt="image-20231010155128568" style="zoom:33%;" />



### 头指针、头结点和首元结点：

![image-20231010155254264](D:\File\markdownPictures\image-20231010155254264.png)

**头指针：**是指向链表中的第一个结点的指针

**首元结点：**是指链表中存储第一个数据元素a1的结点

**头结点：**是在链表的首元结点之前附设的一个结点



**不带头结点：**

<img src="D:\File\markdownPictures\image-20231010155818201.png" alt="image-20231010155818201" style="zoom:33%;" />



**带头结点：**

<img src="D:\File\markdownPictures\image-20231010155837997.png" alt="image-20231010155837997" style="zoom:33%;" />



头结点可以用来存储链表的长度之类的，省去计数时间



### 讨论

讨论1：如何表示空表？

- 无头结点时，头指针为空时表示空表

  <img src="D:\File\markdownPictures\image-20231010160047084.png" alt="image-20231010160047084" style="zoom:33%;" /><img src="D:\File\markdownPictures\image-20231010160113406.png" alt="image-20231010160113406" style="zoom:33%;margin-left:10%" /> 

- 有头结点时，当**头结点的指针域为空**时表示空表

  <img src="D:\File\markdownPictures\image-20231010160429382.png" alt="image-20231010160429382" style="zoom:33%;" />



讨论2：在链表中设置头结点有什么好处？

- 便于**首元结点**的处理：

  首元结点的地址保存在头结点的指针域中，

  所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理

- 便于**空表和非空表**的统一处理：

  无论链表是否为空，头指针都是指向头结点的非空指针，

  因此空表和非空表的处理也就统一了。



讨论3：头结点的**数据域**内装的是什么？

头结点的**数据域**可以为空，也可以存放线性**表长度**等附加信息，但此结点不能计入链表长度值 

<img src="D:\File\markdownPictures\image-20231010160844064.png" alt="image-20231010160844064" style="zoom:33%;" />





### 链表（链式存储结构）的特点

1. 结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。
2. 访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等

这种方法被称为**顺序存储法**

 



### 带头结点的单链表

![image-20231010163104029](D:\File\markdownPictures\image-20231010163104029.png)

![image-20231010163150059](D:\File\markdownPictures\image-20231010163150059.png)

单链表是**由表头**唯一确定，因此单链表可以用**头指针**的名字来命名，若头指针名为L，则把链表成为**表L**



### 单链表的存储结构

![image-20231010164536818](D:\File\markdownPictures\image-20231010164536818.png)





## 区别

顺序表：随机存储

链表：顺序存储



