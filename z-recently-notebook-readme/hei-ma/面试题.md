# 消息中间件

## RabbitMQ

- 消息不丢失  √
- 消息重复消费  √
- 消息堆积
- 延迟队列
- 死信队列
- 高可用机制



### 如何保证消息不丢失

生产者 -> 交换机 -> 队列 -> 消费者

#### 怎么丢失

生产者发送给交换机，交换机分发给队列，队列发送给消费者

- 每一个环节都有可能消息丢失（消息未达到交换机、消息未达到队列）
- MQ宕机
- 消费者服务宕机（未接收到）



#### 如何保证

1. 生产者确认机制

   消息发送到MQ后，会返回一个结果给发送者，表示消息是否处理成功

   **消息未达到，处理方案：**

   回调方法，即时重发

   记录日志

   保存在数据库然后定时重发，发送后从数据库删除

2. MQ宕机？

   默认内存存储消息，开启持久化保存缓存在MQ中的消息不丢失

   交换机持久化、队列持久化、消息持久化
   
3. 消费者未接收到？消费者确认

   消费者处理消息后，给MQ发回执ack，收到回执后删除消息

   三种确认：手动、自动、关闭（默认消费者处理成功）



#### 面试官问题：

1. 如何保证消息不丢失？

开启生产者确认机制，确保生产者的消息可以到队列，报错就记录到日志，修复数据

开启持久化，确保未消费前都在队列中不会丢失，交换机、队列、消息都要做持久化

开启消费者确认机制，spring确认消息处理成功后完成ack，回执

开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，人工处理



### 重复消费问题

1. 消费者处理完毕后，因为网络抖动，没有告诉MQ消息处理完毕了，MQ的重试机制导致重复消费  

   **解决方案：** 每条消息设置一个唯一的标识id、幂等方案（分布式锁、数据库锁）

   存储业务id，消费的时候检查业务id是否存在，存在则说明消费过了

<img src="D:\File\markdownPictures\image-20240828234859946.png" alt="image-20240828234859946" style="zoom:50%;" />





### 死信问题（消息堆积）

消费者处理速度，小于生产者发送速度，就会导致队列消息堆积，可能会被丢弃

1. 增加消费者
2. 消费者内开启线程池提高处理速度
3. 扩大队列容积，提高堆积上线



惰性队列：

接收到消息后存储在磁盘中，而非内存中

消费者要消费消息才会从磁盘中读取并加载到内存

