# 特别感谢

视频教程：https://www.bilibili.com/video/BV1gW421P7RD



## 无伤速通版本

- JDK17
- Cloud 2023.0.0
- SpringBoot 3.2.0
- Cloud Alibaba 2022.0.0.0-RC2
- Maven 3.9
- MySQL 8.0



## 注意事项

如果同时使用Boot和Cloud，将由Cloud来决定Boot的版本

### 版本发布说明

[Home · alibaba/spring-cloud-alibaba Wiki (github.com)](https://github.com/alibaba/spring-cloud-alibaba/wiki)

已迁移至：[版本发布说明 | Spring Cloud Alibaba (aliyun.com)](https://sca.aliyun.com/zh-cn/docs/2022.0.0.0/overview/version-explain)



# 简述

## 七个常用的主流维度（Spring Cloud 2024）

- **服务注册与发现**

  Eureka（不推荐）

  Consul

  Alibaba Nacos

- **服务调用与负载均衡**

  Ribbon（停更）

  LoadBalancer

  OpenFeign

- **分布式事务**

  Alibaba Seata

  LCN

  Hmily

- **服务熔断和降级**

  Hystrix（不再使用）

  Circuit Breaker（断路器）

  Alibaba Sentinel

- **服务链路追踪**

  Sleuth + Zipkin （退出中..）

  Micrometer Tracing

- **服务网关**

  Zuul（退..）

  GateWay

- **分布式配置管理**

  Consul

  Alibaba Nacos



## 创建项目

- 设置packing为pom，代表其为父工程

- Maven使用`dependencyManagement`元素提供管理以来版本号的方式

  **传递依赖**

  通常会在一个组织或项目的最顶层的父POM中看到`dependencyManagement`元素

  pom.xml中的`dependencyManagement`元素，能让所有子项目中引用一个依赖，而不显示的列出版本号

  Maven会沿着父子层次向上走，直到找到一个拥有`dependencyManagement`元素的项目，使用其指定的版本号
  **子项目**会直接使用父类的版本，不需要再额外引入。如果需要别的版本，直接加入version标签即可

  **为什么会爆红**

  只是对依赖进行管理，并不实际引入

  **解决方案：**取消`dependencyManagement`标签，让Maven进行依赖下载，再加上`dependencyManagement`标签即可

- 打包启动慢，可以勾选Maven跳过单元测试的按钮



## 使用技术亮点

- Mapper4：类似MyBatisPlus的简便MyBatis开发工具

- 引入了mybatis-generator后，编写配置文件...

  双击`Maven`**-**`Plugins`**-**`mybatis`**-**`generator`**-**`mybatis-generator:generate`

  即可自动生成**entities**和**mapper** + **mapper.xml**

  



## 建微服务

1. 建module
2. 改pom
3. 写yml
4. 主启动
5. 业务类



## 小Tips

1. 启动类上，加`@MapperScan("com.chenix.cloud.mapper")`

   就可以不用在每个`xxxMapper`上写@Mapper注解了

2. 不方便暴露给前端的字段，可以写一个XxxDTO实体类进行暴露

   不能暴露的就放在Xxx

3. mybatis-generator就是专门快速生成entities和mapper用的，将其复制粘贴到主要的项目中

   然后删除mybatis-generator下的，避免指向出错

4. 注入可以用@Autowired，也可以用@Resource，看个人习惯

   @Autowired容易警告

5. 因为给前端看的是XxxDTO，前端传来的XxxDTO要拷贝到服务端处理的Xxx中

   使用如下代码进行拷贝：

   ```java
   Pay pay = new Pay();
   BeanUtils.copyProperties(payDTO, pay);
   ```

6. 引用knife4j，访问 `ip:port/doc.html`

   ```xml
   <dependency>
       <groupId>com.github.xiaoymin</groupId>
       <artifactId>knife4j-openapi3-jakarta-spring-boot-starter</artifactId>
       <version>${knife4j.version}</version>
   </dependency>
   ```

   ```yaml
   # knife4j
   knife4j:
     enable: true
     setting:
       language: zh_cn
   # springdoc-openapi项目配置
   springdoc:
     swagger-ui:
       path: /swagger-ui.html
       tags-sorter: alpha
       operations-sorter: alpha
     api-docs:
       path: /v3/api-docs
     group-configs:
       - group: 'default'
         paths-to-match: '/**'
         packages-to-scan: com.chenix.cloud.controller
   ```



## 调整不足

1. 时间日志格式的统一和定制情况：配置文件添加时间格式化

   ```yaml
   spring:
   	jackson:
     		date-format: yyyy-MM-dd HH:mm:ss
     			time-zone: GMT+8
   ```

   **非SpringBoot项目**，可以在实体类的对应参数上进行设置

   `@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")`

2. 返回给客户端的数据种类过多，可封装统一的返回值

   code，msg，data 可扩展-timestamp（接口调用时间）

3. 枚举步骤 罗列-构造-遍历

   **罗列**

   ```java
   // 操作失败
   RC999("999", "操作XXX失败"),
   // 操作成功
   RC200("200", "success"),
   // 服务降级
   RC201("201", "服务开启降级保护,请稍后再试!"),
   ```

   **构造**

   ```java
   // 自定义状态码
   private final String code;
   // 自定义描述
   private final String message;
   ReturnCodeEnum(String code, String message) {
       this.code = code;
       this.message = message;
   }
   ```

   **遍历**

   ```java
   //遍历枚举V1
   public static ReturnCodeEnum getReturnCodeEnum(String code) {
       for (ReturnCodeEnum element : ReturnCodeEnum.values()) {
           if (element.getCode().equalsIgnoreCase(code)) {
               return element;
           }
       }
       return null;
   }
   
   //遍历枚举V2
   public static ReturnCodeEnum getReturnCodeEnumV2(String code) {
       return Arrays.stream(ReturnCodeEnum.values())
           .filter(x -> x.getCode().equalsIgnoreCase(code))
           .findFirst()
           .orElse(null);
   }
   ```

   **测试**

   ```java
   System.out.println(getReturnCodeEnumV2("200"));
   System.out.println(getReturnCodeEnumV2("200").getCode());
   System.out.println(getReturnCodeEnumV2("200").getMessage());
   ```

4. 新建统一的返回对象

   ```java
   @Data
   @Accessors(chain = true)
   public class ResultData<T> {
       private String code;
       /**
        * 结果状态 ,具体状态码参见枚举类ReturnCodeEnum.java
        */
       private String message;
       private T data;
       private long timestamp;
       public ResultData() {
           this.timestamp = System.currentTimeMillis();
       }
       public static <T> ResultData<T> success(T data) {
           ResultData<T> resultData = new ResultData<>();
           resultData.setCode(ReturnCodeEnum.RC200.getCode());
           resultData.setMessage(ReturnCodeEnum.RC200.getMessage());
           resultData.setData(data);
           return resultData;
       }
       public static <T> ResultData<T> fail(String code, String message) {
           ResultData<T> resultData = new ResultData<>();
           resultData.setCode(code);
           resultData.setMessage(message);
           return resultData;
       }
   }
   ```

5. 全局异常接入返回的标准格式

   



## 小Tips V2

1. Lombok里的一个注解：`@Accessors(chain = true)`

   使用该注解配置，当new一个对象，可以直接进行各种set操作后，返回该对象

   ```java
   Xxx xxx = new Xxx().setName("chenix").setAge(18)
   ```

   参考Blog：[@Accessors 注解详解-CSDN博客](https://blog.csdn.net/sunnyzyq/article/details/119992746)



## 小小引入微服务概念

> Rest Template提供了多种便捷访问远程Http服务的方法， 
>
> 是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集

### 订单微服务80如何才能调用到支付微服务8001？

delete无法获取返回值解决方案：[RestTemplate的put,delete请求接收返回值_resttemplate put方法 响应-CSDN博客](https://blog.csdn.net/weixin_38373006/article/details/88849494)































