# 特别感谢

视频教程：https://www.bilibili.com/video/BV1gW421P7RD



## 无伤速通版本

- JDK17
- Cloud 2023.0.0
- SpringBoot 3.2.0
- Cloud Alibaba 2022.0.0.0-RC2
- Maven 3.9
- MySQL 8.0



## 注意事项

如果同时使用Boot和Cloud，将由Cloud来决定Boot的版本

### 版本发布说明

[Home · alibaba/spring-cloud-alibaba Wiki (github.com)](https://github.com/alibaba/spring-cloud-alibaba/wiki)

已迁移至：[版本发布说明 | Spring Cloud Alibaba (aliyun.com)](https://sca.aliyun.com/zh-cn/docs/2022.0.0.0/overview/version-explain)



# 复习专用

> 由于个人经常隔很长一段时间，间断性学习，因此记录快速复习流程

- **打开consul注册中心**

  localhost:8500

- 依次启动服务**提供者**：cloud-payment-service-8001/8002

  访问测试：localhost:8001/pay/getInfo   and   localhost:8002/pay/getInfo

  【此前步骤由Consul完成】

- 启动服务**调用者：** cloud-consumer-openfeign-order

  访问测试：localhost/feign/pay/mylb

  做了负载均衡，返回信息应在8001和8002横跳

  【此步骤由OpenFeign完成】

- [![pkYD56K.md.png](https://s21.ax1x.com/2024/06/06/pkYD56K.md.png)](https://imgse.com/i/pkYD56K)





















# 简述

## 七个常用的主流维度（Spring Cloud 2024）

- **服务注册与发现**

  Eureka（不推荐）

  Consul

  Alibaba Nacos

- **服务调用与负载均衡**

  Ribbon（停更）

  LoadBalancer

  OpenFeign

- **分布式事务**

  Alibaba Seata

  LCN

  Hmily

- **服务熔断和降级**

  Hystrix（不再使用）

  Circuit Breaker（断路器）

  Alibaba Sentinel

- **服务链路追踪**

  Sleuth + Zipkin （退出中..）

  Micrometer Tracing

- **服务网关**

  Zuul（退..）

  GateWay

- **分布式配置管理**

  Consul

  Alibaba Nacos



## 创建项目

- 设置packing为pom，代表其为父工程

- Maven使用`dependencyManagement`元素提供管理以来版本号的方式

  **传递依赖**

  通常会在一个组织或项目的最顶层的父POM中看到`dependencyManagement`元素

  pom.xml中的`dependencyManagement`元素，能让所有子项目中引用一个依赖，而不显示的列出版本号

  Maven会沿着父子层次向上走，直到找到一个拥有`dependencyManagement`元素的项目，使用其指定的版本号
  **子项目**会直接使用父类的版本，不需要再额外引入。如果需要别的版本，直接加入version标签即可

  **为什么会爆红**

  只是对依赖进行管理，并不实际引入

  **解决方案：**取消`dependencyManagement`标签，让Maven进行依赖下载，再加上`dependencyManagement`标签即可

- 打包启动慢，可以勾选Maven跳过单元测试的按钮



## 使用技术亮点

- Mapper4：类似MyBatisPlus的简便MyBatis开发工具

- 引入了mybatis-generator后，编写配置文件...

  双击`Maven`**-**`Plugins`**-**`mybatis`**-**`generator`**-**`mybatis-generator:generate`

  即可自动生成**entities**和**mapper** + **mapper.xml**

  



## 建微服务

1. 建module
2. 改pom
3. 写yml
4. 主启动
5. 业务类



## 小Tips

1. 启动类上，加`@MapperScan("com.chenix.cloud.mapper")`

   就可以不用在每个`xxxMapper`上写@Mapper注解了

2. 不方便暴露给前端的字段，可以写一个XxxDTO实体类进行暴露

   不能暴露的就放在Xxx

3. mybatis-generator就是专门快速生成entities和mapper用的，将其复制粘贴到主要的项目中

   然后删除mybatis-generator下的，避免指向出错

4. 注入可以用@Autowired，也可以用@Resource，看个人习惯

   @Autowired容易警告

5. 因为给前端看的是XxxDTO，前端传来的XxxDTO要拷贝到服务端处理的Xxx中

   使用如下代码进行拷贝：

   ```java
   Pay pay = new Pay();
   BeanUtils.copyProperties(payDTO, pay);
   ```

6. 引用knife4j，访问 `ip:port/doc.html`

   ```xml
   <dependency>
       <groupId>com.github.xiaoymin</groupId>
       <artifactId>knife4j-openapi3-jakarta-spring-boot-starter</artifactId>
       <version>${knife4j.version}</version>
   </dependency>
   ```

   ```yaml
   # knife4j
   knife4j:
     enable: true
     setting:
       language: zh_cn
   # springdoc-openapi项目配置
   springdoc:
     swagger-ui:
       path: /swagger-ui.html
       tags-sorter: alpha
       operations-sorter: alpha
     api-docs:
       path: /v3/api-docs
     group-configs:
       - group: 'default'
         paths-to-match: '/**'
         packages-to-scan: com.chenix.cloud.controller
   ```



## 调整不足

1. 时间日志格式的统一和定制情况：配置文件添加时间格式化

   ```yaml
   spring:
    jackson:
           date-format: yyyy-MM-dd HH:mm:ss
              time-zone: GMT+8
   ```

   **非SpringBoot项目**，可以在实体类的对应参数上进行设置

   `@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss", timezone = "GMT+8")`

2. 返回给客户端的数据种类过多，可封装统一的返回值

   code，msg，data 可扩展-timestamp（接口调用时间）

3. 枚举步骤 罗列-构造-遍历

   **罗列**

   ```java
   // 操作失败
   RC999("999", "操作XXX失败"),
   // 操作成功
   RC200("200", "success"),
   // 服务降级
   RC201("201", "服务开启降级保护,请稍后再试!"),
   ```

   **构造**

   ```java
   // 自定义状态码
   private final String code;
   // 自定义描述
   private final String message;
   ReturnCodeEnum(String code, String message) {
       this.code = code;
       this.message = message;
   }
   ```

   **遍历**

   ```java
   //遍历枚举V1
   public static ReturnCodeEnum getReturnCodeEnum(String code) {
       for (ReturnCodeEnum element : ReturnCodeEnum.values()) {
           if (element.getCode().equalsIgnoreCase(code)) {
               return element;
           }
       }
       return null;
   }
   
   //遍历枚举V2
   public static ReturnCodeEnum getReturnCodeEnumV2(String code) {
       return Arrays.stream(ReturnCodeEnum.values())
           .filter(x -> x.getCode().equalsIgnoreCase(code))
           .findFirst()
           .orElse(null);
   }
   ```

   **测试**

   ```java
   System.out.println(getReturnCodeEnumV2("200"));
   System.out.println(getReturnCodeEnumV2("200").getCode());
   System.out.println(getReturnCodeEnumV2("200").getMessage());
   ```

4. 新建统一的返回对象

   ```java
   @Data
   @Accessors(chain = true)
   public class ResultData<T> {
       private String code;
       /**
        * 结果状态 ,具体状态码参见枚举类ReturnCodeEnum.java
        */
       private String message;
       private T data;
       private long timestamp;
       public ResultData() {
           this.timestamp = System.currentTimeMillis();
       }
       public static <T> ResultData<T> success(T data) {
           ResultData<T> resultData = new ResultData<>();
           resultData.setCode(ReturnCodeEnum.RC200.getCode());
           resultData.setMessage(ReturnCodeEnum.RC200.getMessage());
           resultData.setData(data);
           return resultData;
       }
       public static <T> ResultData<T> fail(String code, String message) {
           ResultData<T> resultData = new ResultData<>();
           resultData.setCode(code);
           resultData.setMessage(message);
           return resultData;
       }
   }
   ```

5. 全局异常接入返回的标准格式

   



## 小Tips V2

1. Lombok里的一个注解：`@Accessors(chain = true)`

   使用该注解配置，当new一个对象，可以直接进行各种set操作后，返回该对象

   ```java
   Xxx xxx = new Xxx().setName("chenix").setAge(18)
   ```

   参考Blog：[@Accessors 注解详解-CSDN博客](https://blog.csdn.net/sunnyzyq/article/details/119992746)



## 小小引入微服务概念

> Rest Template提供了多种便捷访问远程Http服务的方法， 
>
> 是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集

### 订单微服务80如何才能调用到支付微服务8001？

delete无法获取返回值解决方案：[RestTemplate的put,delete请求接收返回值_resttemplate put方法 响应-CSDN博客](https://blog.csdn.net/weixin_38373006/article/details/88849494)

**通过RestTemplate**

> -config
>
>  -RestTemplateConfig.java

```java
@Configuration
public class RestTemplateConfig {
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

  

> **controller示例**
>
> - 使用RestTemplate + 远程服务的连接 调用远程服务接口

```java
@RestController
@RequestMapping("/order/pay")
public class OrderController {
    public static final String PAYMENT_SRV_URL = "http://localhost:8001";
    @Resource
    private RestTemplate restTemplate;

    @PostMapping(value = "/add")
    public ResultData addOrder(PayDTO payDTO) {
        return restTemplate.postForObject(PAYMENT_SRV_URL + "/pay/add", payDTO, ResultData.class);
    }

    @DeleteMapping(value = "/delete/{id}")
    public void deleteOrder(@PathVariable("id") Integer id) {
        restTemplate.delete(PAYMENT_SRV_URL + "/pay/delete/" + id, id);
    }

    @GetMapping(value = "/get/{id}")
    public ResultData getById(@PathVariable("id") Integer id) {
        return restTemplate.getForObject(PAYMENT_SRV_URL + "/pay/get/" + id, ResultData.class, id);
    }

    @PutMapping(value = "/update")
    public ResultData update(@RequestBody PayDTO payDTO) {
        System.out.println("处理的数据：" + payDTO);
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        HttpEntity<String> request = new HttpEntity<>(JSON.toJSON(payDTO).toString(), headers);
        ResponseEntity<ResultData> exchange = restTemplate.exchange(
                PAYMENT_SRV_URL + "/pay/update",
                HttpMethod.PUT,
                request,
                ResultData.class
        );
        return exchange.getBody();
    }

    @GetMapping(value = "/getAll")
    public ResultData getAll() {
        return restTemplate.getForObject(PAYMENT_SRV_URL + "/pay/all", ResultData.class);
    }
}
```



## 观察问题

### 其一（重复模块）

**存在问题：**order服务和provider服务存在重复代码

[![pFoN5GV.png](https://s21.ax1x.com/2024/03/28/pFoN5GV.png)](https://imgse.com/i/pFoN5GV)











**解决方案：**抽取公共部分，新建一个服务，存放对外暴露的组件/api/接口/工具类...

`cloud-api-commons`，将复用性高的部分放进去，并进行install操作，成为一个jar包

成为jar包后，在各个服务中进行应用即可

### 其二（Controller中写死的硬编码URL）

[![pFoaTHJ.png](https://s21.ax1x.com/2024/03/28/pFoaTHJ.png)](https://imgse.com/i/pFoaTHJ)





微服务所在的IP地址和端口号硬编码到订单微服务中，会存在非常多的问题

（1）如果订单微服务和支付微服务的IP地址或者端口号发生了变化，则支付微服务将变得不可用，需要同步修改订单微服务中调用支付微服务的IP地址和端口号。

（2）如果系统中提供了多个订单微服务和支付微服务，则无法实现微服务的负载均衡功能。

（3）如果系统需要支持更高的并发，需要部署更多的订单微服务和支付微服务，硬编码订单微服务则后续的维护会变得异常复杂。 

所以，在微服务开发的过程中，需要引入**服务治理功能**，实现微服务之间的动态注册与发现，从此刻开始我们正式进入SpringCloud实战



# Consul服务注册与发现

## 以前的服务注册中心Eureka

**为什么不用？**

1. 停更

2. 没有与业务代码解耦，混为一谈了

   目标是为了得到一个单独隔离出来的，而不是作为微服务的一部分嵌入到系统中

3. Alibaba Nacos 崛起



## 官网

[Consul by HashiCorp](https://www.consul.io/)

## What is Consul?

HashiCorp Consul is a service networking solution that enables teams to manage secure network connectivity between services and across on-prem and multi-cloud environments and runtimes. Consul offers service discovery, service mesh, traffic management, and automated updates to network infrastructure device. You can use these features individually or together in a single Consul deployment.

## Spring-Cloud

https://spring.io/projects/spring-cloud-consul

Spring Cloud Consul provides [Consul](http://consul.io/) integrations for Spring Boot apps through autoconfiguration and binding to the Spring Environment and other Spring programming model idioms. With a few simple annotations you can quickly enable and configure the common patterns inside your application and build large distributed systems with Hashicorp’s Consul. The patterns provided include Service Discovery, Distributed Configuration and Control Bus.

## 能干嘛

1. 服务发现：提供HTTP和DNS两种发现方式
2. 健康检测：支持多种方式，HTTP、TCP、Docker、Shell脚本定制化监控
3. KV存储
4. 多数据中心
5. 可视化Web界面

#### 特点（En）

Features of Consul

- Distributed configuration
- Service registration and discovery
- Distributed events
- Distributed locking and sessions
- Supports multiple data centers
- Built in, user-friendly user interface

## 下载

地址：https://developer.hashicorp.com/consul/install

## 解压 并查看版本

在解压的目录下看到consul.exe，使用consul --version查看版本

```bash
D:\software\consul_1.18.1_windows_386>consul --version
Consul v1.18.1
Revision 98cb473c
Build Date 2024-03-26T21:59:08Z
Protocol 2 spoken by default, understands 2 to 3 (agent will automatically use protocol >2 when speaking to compatible agents)
```

## 以开发者模式启动

**命令：**`consul agent -dev`

**访问地址：**http://localhost:8500/

## 拓展

如何知道启动端口为8500？

查看Github的readme

## ....

## 注入服务

### 引入依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-consul-discovery</artifactId>
</dependency>
```

### 编写配置文件

```yaml
spring:
  application:
    name: cloud-payment-service
  cloud:
    # consul 配置
    consul:
      host: localhost
      port: 8500
      discovery:
        service-name: ${spring.application.name}
```

### 主启动，激活

Application上添加`@EnableDiscoverClient`

### 修复提示警告

Standard Commons Logging discovery in action with spring-jcl: please remove commons-logging.jar from classpath in order to avoid potential conflicts

说，请移除 commons-logging.jar

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-consul-discovery</artifactId>
    <exclusions>
        <exclusion>
            <groupId>commons-logging</groupId>
            <artifactId>commons-logging</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

## 解决硬编码URL

将provider和order都注入到注册中心后

order部分原本使用的硬编码

```java
public static final String PAYMENT_SRV_URL = "http://localhost:8001";
```

就可以修改为：

**ps：** cloud-payment-service是provider在注册中心上的名称

```java
public static final String PAYMENT_SRV_URL = "http://cloud-payment-service";
```



## 解决报错

### 问题

运行后，访问order端的接口，报错：

`java.net.UnknownHostException:cloud-payment-service`

```bash
org.springframework.web.client.ResourceAccessException: I/O error on GET request for "http://cloud-payment-service/pay/all": cloud-payment-service
...
Caused by: java.net.UnknownHostException: cloud-payment-service
```



### 解决方案

在**RestTemplate**工具类上加上`@LoadBalanced`

因为用的是**微服务名称**访问，该服务名可能作为一个集群，其下可能存在多个**微服务**

因此添加`@LoadBalanced`进行负载平衡



# Consul服务配置与刷新

微服务意味着要将单体应用的业务拆分成一个个子服务

由于每个服务都需要必要的配置信息

所以需要一套集中式、动态的配置管理设施

比如某些配置文件的内容大部分相同，当主机迁移的时候

我们希望一次迁移，处处生效



## 需求

通用全局配置信息，直接注册到consul服务器，从consul服务器获取

遵循consul配置规则要求



## 导包

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-consul-config</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bootstrap</artifactId>
</dependency>
```



## 按照如下路径进行配置文件编写

```
config/testApp,dev/
config/testApp/
config/application,dev/
config/application/
```

### 新增配置文件bootstrap.yml

> - application.yml 是用户级的资源配置项
> - bootstrap.yml      系统级的，优先级更高

两者可以共有，相同配置，优先读取`bootstrap.yml`

```yml
spring:
  application:
    name: cloud-payment-service
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        service-name: ${spring.application.name}
      config:
        profile-separator: '-' # default value is ","，we update '-'
        format: YAML
```

Consul provides a [Key/Value Store](https://consul.io/docs/agent/http/kv.html) for storing configuration and other metadata. Spring Cloud Consul Config is an alternative to the [Config Server and Client](https://github.com/spring-cloud/spring-cloud-config). Configuration is loaded into the Spring Environment during the special "bootstrap" phase. Configuration is stored in the `/config` folder by default. Multiple `PropertySource` instances are created based on the application’s name and the active profiles that mimics the Spring Cloud Config order of resolving properties. For example, an application with the name "testApp" and with the "dev" profile will have the following property sources created:

```
config/testApp,dev/
config/testApp/
config/application,dev/
config/application/
```

**大致解释：**在consul启动的8500页面中，K/V中添加配置文件，格式严格遵守如上

因为“-”比“,”更符合习惯，因此在bootstrap.yml配置中已经更换了config profile-separator分隔符

## 在8500端口服务的consul页面中进行KV配置

1. 左侧选中 Key/Value

   右上角Create

   输入 `config/`

   **有'/'表示创建的是文件夹，不是文件**

2. 进入 config目录

   依次新建 cloud-payment-service/  |   cloud-payment-service-dev   |   cloud-payment-service-prod

   cloud-payment-service与配置文件对应服务的application-name相同

3. 进入 cloud-payment-service 目录，分别创建data，不需要斜杠

### 测试

```java
@Value("${server.port}")
private String port;
@Value("${chenix.info}")
private String msg;

@GetMapping("/getInfo")
public String getInfo() {
    return msg + ":" + port;
}
```



## 动态变更

**需求**

consul服务器上kv中的data内容已经改变

但是本地没有立刻生效

需要实现动态及时刷新，服务器变更，本地立马获取



**解决方案**

`@RefreshScope`注解添加到主启动类

一个不建议修改的参数，做理解使用：

表示服务器更新后，等待多久，本地会刷新

默认55s

```yml
spring:
  cloud:
    consul:
      config:
        watch:
          wait-time: 1
```



### 小踩坑

提前在接口前就通过@Value获取了consul上的值

因此就算修改了consul的kv值，也无法实时刷新

需要将该值放入接口的参数当中

```java
@GetMapping("/getInfo")
public String getInfo(@Value("${chenix.info}") String msg) {
    return msg + ":" + port;
}
```



# 【waiting..】Consul持久化

之前的配置，一旦consul重启，都会作废

因此需要进行consul的配置持久化...

## 数据持久化配置并注册为Windows服务

在consul的目录中创建mydata文件夹

并编写`consul_start.bat`脚本运行

使其成为后台程序并绑定mydata文件夹进行持久化配置的本地存储

```bash
@echo.服务启动......  
@echo off  
@sc create Consul binpath= "[consul目录]\consul.exe agent -server -ui -bind=127.0.0.1 -client=0.0.0.0 -bootstrap-expect  1  -data-dir [mydata目录，一般与consul.exe同级]   "
@net start Consul
@sc config Consul start= AUTO  
@echo.Consul start is OK......success
@pause
```

以管理员运行`consul_start.bat`



# LoadBalancer负载均衡服务调用

## 以前负载均衡服务调用Ribbon

是Netflix Ribbon实现的一套负载平衡工具

主要用于提供客户端软件负载均衡算法和服务调用



## 官网查看

在 `spring-cloud-commons` 下

[Cloud Native Applications (spring.io)](https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-loadbalancer)



**LoadBalancer本地负载均衡客户端** 和 **Nginx服务端负载均衡** 的区别

- LoadBalancer是在调用微服务接口的时候，会在注册中心上获取注册信息服务列表之后，缓存到JVM本地，从而在本地实现RPC远程服务调用技术

  自己找

- Nginx是客户端将所有请求都交给Nginx，Nginx实现转发请求





## LoadBalancer工作步骤

1. 选择Consul Server从服务端查询并拉取服务列表，查询到了多个实现完全一样的服务。

   默认轮询调用谁都可以正常执行。客户端自己选一个服务进行调用执行

2. 按照指定的负载均衡策略从server取到的服务注册列表中，由客户端自己选择一个地址。

   所以Load Balancer是一个客户端的负载均衡器





## 模拟负载均衡

- 80消费端引入loadbalancer依赖

  ```xml
  <dependency>
      <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-loadbalancer</artifactId>
  </dependency>
  ```

- 80消费端controller写入getInfo

- 浏览器访问80消费端的getInfo，可以发现在8001与8002之间相互调用



## DiscoveryClient解析

> - getServices()：可以获取发现的所有服务
> - getInstances()：获取具体的实例
> - ...

```java
@Resource
private DiscoveryClient discoveryClient;

@GetMapping("/discovery")
public String discovery() {
    List<String> services = discoveryClient.getServices();
    for (String element : services) {
        System.out.println(element);
    }

    System.out.println("===================================");

    List<ServiceInstance> instances = discoveryClient.getInstances("cloud-payment-service");
    for (ServiceInstance element : instances) {
        System.out.println(element.getServiceId() + "\t" + element.getHost() + "\t" + element.getPort() + "\t" + element.getUri());
    }

    return instances.get(0).getServiceId() + ":" + instances.get(0).getPort();
}
```

**打印如下：**

```bash
cloud-consumer-order
cloud-payment-service
consul
===================================
cloud-payment-service   localhost  8001   http://localhost:8001
cloud-payment-service   localhost  8002   http://localhost:8002
```



### 负载均衡算法

rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标



## LoadBalancer算法

### 默认算法

轮询

### 算法切换

可切换其他默认算法：随机..







# 👆 二选一 👇 （一般用 👇）



# OpenFeign

> 服务调用和负载均衡

## 小记

有问题，翻翻官方文档

[spring-cloud/spring-cloud-openfeign: Support for using OpenFeign in Spring Cloud apps (github.com)](https://github.com/spring-cloud/spring-cloud-openfeign)

## 概述

> - 是一个声明式的Web服务客户端
>
>
> - 只需要创建一个Rest接口，在其上方添加注解`@FeignClient`即可

并且支持负载均衡

OpenFeign基本上就是目前为服务之间调用的事实标准



### OpenFeign能干什么

之前使用SpringCloud LoadBalancer + RestTemplate的时候，利用RestTemplate对http请求的封装处理形成了一套模板化的调用方法。

实际开发中，由于对服务依赖的调用可能不止一处，**往往一个接口会被多处调用，通常会对每个微服务自行封装一些客户端类来包装这些依赖微服务的调用。**

在OpenFeign的帮助下，**只需要创建一个接口并使用注解的方式来配置它（在一个微服务接口上面标注一个@FeignClient注解即可）**



同时OpenFeign还集成了SpringCloud LoadBalancer

可以在使用OpenFeign的时候提供Http客户端的负载均衡，也可以集成阿里巴巴Sentinel来提供熔断、降级..功能

与SpringCloud LoadBalancer不同的是，**通过OpenFeign只需要定义服务绑定接口且以声明式的方法。**



## OpenFeign通用步骤

1. 接口+注解

   - 微服务API接口 + @FeignClient注解标签
   - 服务消费者80 -> 调用含有@FeignClient注解的API服务接口 -> 服务提供者(8001/8002)

2. 流程步骤

   1. 建Module

   2. 改pom（写入依赖）

      ```xml
      <!--openfeign-->
      <dependency>
          <groupId>org.springframework.cloud</groupId>
          <artifactId>spring-cloud-starter-openfeign</artifactId>
      </dependency>
      ```

   3. 写yml

      ```yaml
      server:
        port: 80
      spring:
        application:
          name: cloud-consumer-openfeign-order
        ####Spring Cloud Consul for Service Discovery
        cloud:
          consul:
            host: localhost
            port: 8500
            discovery:
              prefer-ip-address: true #优先使用服务ip进行注册
              service-name: ${spring.application.name}
      ```

   4. 主启动（修改启动类名）

      ```java
      @SpringBootApplication
      @EnableFeignClients
      public class MainOpenFeign80
      {
          public static void main(String[] args){
              SpringApplication.run(MainOpenFeign80.class,args);
          }
      }
      ```

      **PS：**添加`@EnableFeignClients`注解开启OpenFeign功能并激活

      > @EnableDiscoveryClient // 向consul注册中心注册服务
      > @EnableFeignClients // 开启OpenFeign功能并激活

   5. 业务类..

      - 写入api-commons

        引入OpenFeign依赖

        新建服务接口`PayFeignApi`，配置`@FeignClient`注解
        
        等同于一个 对外暴露服务 的 清单
        
        提供者哪些服务可以被调用，直接在PayFeignApi中作为接口（interface）声明出来
        
        ```java
        // value中写服务名称（直接从consul注册中心里复制）
        @FeignClient(value = "cloud-payment-service")
        public interface PayFeignApi {
            @GetMapping("/pay/getInfo")
            public String getInfo();
            @GetMapping(value = "/pay/get/{id}")
            public ResultData<PayDTO> getPayById(@PathVariable("id") Integer id);
            @PostMapping(value = "/add")
            public ResultData<String> addPay(@RequestBody PayDTO payDTO);
        }
        ```



## OpenFeign对比RestTemplate

### 消费者端...

### 以前RestTemplate

#### 编写配置类

> -config
>
>  -RestTemplateConfig.java

```java
@Configuration
public class RestTemplateConfig {
    @Bean
    @LoadBalanced
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```

#### controller中定义URL

> -controller
>
>  -OrderController.java

```java
@RestController
@RequestMapping("/order/pay")
public class OrderController {
    public static final String PAYMENT_SRV_URL = "http://cloud-payment-service";

    @Resource
    private RestTemplate restTemplate;

    @PostMapping(value = "/add")
    public ResultData addOrder(PayDTO payDTO) {
        return restTemplate.postForObject(PAYMENT_SRV_URL + "/pay/add", payDTO, ResultData.class);
    }
    
    ...
}
```

### 现在使用OpenFeign

#### 公共接口包中指定远程服务

> -api-commons的Module中
>
>  -apis
>
>     -PayFeignApi.java (interface)

```java
@FeignClient(value = "cloud-payment-service")
public interface PayFeignApi {
    @GetMapping("/pay/getInfo")
    public String getInfo();

    @GetMapping(value = "/pay/get/{id}")
    public ResultData<PayDTO> getPayById(@PathVariable("id") Integer id);

    @PostMapping(value = "/add")
    public ResultData<String> addPay(@RequestBody PayDTO payDTO);
}
```

### controller中调用公共接口包

> -消费者包中
>
>  -controller
>
>     -OrderController.java

```java
@RestController
@RequestMapping("/feign/pay")
public class OrderController {
    @Resource
    private PayFeignApi payFeignApi;

    @PostMapping(value = "/add")
    public ResultData addOrder(PayDTO payDTO) {
        System.out.println("假装新增");
        return payFeignApi.addPay(payDTO);
    }

    @GetMapping(value = "/mylb")
    public String getInfo(){
        System.out.println("模拟getInfo");
        return payFeignApi.getInfo();
    }

    @GetMapping(value = "/get/{id}")
    public ResultData getPayById(@PathVariable("id") Integer id) {
        System.out.println("模拟getById");
        return payFeignApi.getPayById(id);
    }
}
```



### 测试

- 启动8001
- 启动8002
- 启动OpenFeign80
- 因为OpenFeign天生支持负载均衡，因此可以直接查看/mylb测试

### 服务调用路线

- `FeignConsumer80`服务中注入公共接口（api-commons）中，被`@FeignClient`注解修饰的接口
- 通过`@FeignClient`接口中的value参数，找到注册中心consul中对应的Provider服务
- 通过访问`FeignConsumer80`中的地址，辗转于公共暴露接口->实际服务提供者

例如：

在地址栏访问consumer80的地址：/feign/pay/get/1

会依次访问：consumer80的对应方法->公共接口中的对应接口->@FeignClient指定的服务提供者，对应接口方法



## OpenFeign高级特性

#### 超时控制

模拟超时报错：在被调用的提供者服务当中，编写**sleep代码**

```java
@Operation(summary = "根据ID获取支付记录", description = "根据ID检索支付记录详情")
@GetMapping(value = "/get/{id}")
public ResultData<Pay> getPayById(@PathVariable("id") Integer id) {
    if (id < 0) {
        throw new RuntimeException("id不能为负数");
    }
    try {
        TimeUnit.SECONDS.sleep(61);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
    Pay pay = payService.getById(id);
    return ResultData.success(pay, "获取支付记录成功");
}
```

此时访问消费端调用的@FeignClient标注的公共接口，将进入延时等待。

因为设置的`sleep 61s`，而**OpenFeign默认等待60s**，超过后报错

**yml文件中开启的配置**

```yaml
connectTimeout：连接超时时间
readTimeout：请求处理超时时间
```

##### 示例全局配置

```yaml
spring:
  cloud:
    openfeign:
      client:
        config:
          default:
            #连接超时时间
            connectTimeout: 3000
            #读取超时时间
            readTimeout: 3000
```

此时设置超时时间为3s



##### 指定服务，单个服务配置超时时间

把上面配置文件中的default改成对应的**服务名称**

**服务名称：**与公共接口文件中的`@FeignClient`中的value值对应



#### 重试机制

- 默认重试机制是关闭的：只调用一次就结束

- 开启Retryer功能：

  - 新增配置类FeignConfig并修改Retryer配置

  - 消费者端

    ```java
    @Configuration
    public class FeignConfig {
        @Bean
        public Retryer myRetryer(){
            // 默认不走重试策略
            return Retryer.NEVER_RETRY;
        }
    }
    ```

    👆 默认配置，自定义配置 👇

    ```java
    @Configuration
    public class FeignConfig {
        @Bean
        public Retryer myRetryer() {
           // 初始间隔时间100ms，重试最大间隔时间1s，最大请求次数3次（第一次请求+两次重试）
            return new Retryer.Default(100, 1, 3);
        }
    }
    ```

  - 此时，发送一次仅允许超时4s的请求，一旦超时，最终执行时间为12s

  - 没有Feign日志，不能把三次请求都看到，只能看到一次请求超时。



#### 默认HttpClient修改

> OpenFeign中的HttpClient
>
> 如果不做特殊配置，默认使用JDK自带的HttpURLConnection发送HTTP请求
>
> 由于默认的HttpURLConnection没有连接池，性能和效率都比较低，如果采用默认的，性能上不是最好的

> **官方Tips：**
>
> 从 Spring Cloud OpenFeign 4 开始，不再支持 Feign Apache HttpClient 4。我们建议改用 Apache HttpClient 5。

##### Apache HttpClient5 pom依赖

```xml
<!-- httpclient5-->
<dependency>
    <groupId>org.apache.httpcomponents.client5</groupId>
    <artifactId>httpclient5</artifactId>
    <version>5.3</version>
</dependency>
<!-- feign-hc5-->
<dependency>
    <groupId>io.github.openfeign</groupId>
    <artifactId>feign-hc5</artifactId>
    <version>13.1</version>
</dependency>
```

##### yml配置文件开启hc5

```yaml
#  Apache HttpClient5 配置开启
spring:
  cloud:
    openfeign:
      httpclient:
        hc5:
          enabled: true
```



#### 请求/响应 压缩

是什么？

OpenFeign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗

**开启请求与响应的压缩功能配置：**

```yaml
spring.cloud.openfeign.compression.request.enabled=true
spring.cloud.openfeign.compression.response.enabled=true
```



**细粒度化设置**

配置内容指定的请求数据类型，设置请求压缩的大小下限

```yaml
spring.cloud.openfeign.compression.request.enabled=true
spring.cloud.openfeign.compression.request.mime-types=text/xml,application/xml,application/json# 触发压缩数据类型
spring.cloud.openfeign.compression.request.min-request-size=2048 #最小触发压缩的大小
```



#### 日志打印

**日志级别：**

1. **NONE：**默认不显示任何日志
2. **BASIC：**仅记录请求方法、URL、响应状态码及执行时间
3. **HEADERS：**除了BASIC中定义的信息之外，还有请求和响应的头信息
4. **FULL：**除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据

**因为默认是不显示任何日志**

需要在FeignConfig中开启日志

> -config
>
>  -FeignConfig.java

```java
@Configuration
public class FeignConfig {
    @Bean
    Logger.Level feignLoggerLevel(){
        return Logger.Level.FULL;
    }
}
```

**在application.yml文件中开启日志**s

> 公式： `logging.level` + `含有@FeignClient注解的完整带包名的接口名` + `debug`

例如：监控com.xxx.cloud下的apis包下的PayFeignApi接口

```yaml
# feign日志以什么级别监控哪个接口
logging:
  level:
    com.chenix.cloud.apis.PayFeignApi: debug
```



# CircuitBreaker断路器

> 服务熔断和降级

## Hystrix进入维护模式...

他是一个用于处理分布式系统用的**延迟**和**容错**的开源库

在分布式系统中，许多依赖不可避免地会调用失败，比如超时、异常等

Hystrix能保证在一个依赖出问题的情况下，**不会导致整体服务失败，避免级联故障，提高分布式系统的弹性**

Hystrix在2024已经宣布停更，并随之推荐了**Resilience4j**



## 服务雪崩

在分布式系统中不可避免存在的问题：

多个微服务之间调用，假设**微服务A**<u>调用</u>**微服务B和微服务C**

**微服务B和微服务C**又调用其他的微服务，就是所谓的**“扇出”**

如果扇出的链路上，某个微服务的调用响应时间过长or不可用，对微服务A的调用就会占用越来越多的系统资源

进而引起系统崩溃，所谓的“雪崩效应”

通常发现一个模块下的某个实例失败后，这个模块还会继续接收流量，然后这个有问题的模块还调用了其他模块，这样就会发生级联故障，/ 雪崩



### 解决方案

有问题的节点，快速熔断（快速返回失败处理或返回默认兜底数据【服务降级】）

**“断路器”** 本身是一种开关装置，当某个服务单元发生故障后，通过断路器的故障监控（类似熔断保险丝）

向调用方返回一个不符合预期的、可处理的备选响应（FallBack），而不是长时间等待或抛出调用方无法处理的异常

> 总结：出故障了“保险丝”跳闸，不烧毁整个家



## 断路器能做的事

- 服务熔断：达到最大服务访问后，从`CLOSE供电状态 -> OPEN跳闸状态`。此时调用方会接受服务降级的处理，并返回友好的兜底提示
- 服务降级：服务器忙，请稍后重试...   不让客户端等待，立即返回一个友好提示，fallback
- 服务限流：秒杀高并发等操作，避免一窝蜂进来。排队，1s N个，有序进行
- 服务限时
- 服务预热
- 接收实时的监控
- 兜底的处理动作
- ...

> `Hystrix`淘汰，替代品 -> `SpringCloudCircuitBreaker`（提供实现类`Resilience4J` 和 `Spring Retry`）



## Circuit Breaker - 规范

> ### Supported Implementations - 实现
>
> - [Resilience4J](https://github.com/resilience4j/resilience4j) -> Resilience For Java
> - [Spring Retry](https://github.com/spring-projects/spring-retry)

**Circuit Breaker的目的：** 保护分布式系统面试故障和异常，提高系统的可用性和健壮性

当一个组件或服务出现故障时

CircuitBreaker会迅速切换到开放OPEN状态（保险丝跳闸断电），阻止请求发送到该组件或服务从而避免更多的请求发送到该组作或服务。

这可以减少对该组件或服务的负载，防止该组件或服务进步崩溃，并使整个系统能够继续正常运行。

同时，CircuitBreaker还可以提高系统的可用性和健壮性，因为它可以在分布式系统的各个组件之间自动切换，从而避免单点故障的问题。



### 三个状态

- CLOSED：闭合状态，正常运行
- OPEN：出问题，断闸
- HALF_OPEN：半开，发几个请求尝试（探路）
  - 尝试成功，状态->CLOSED恢复正常
  - 尝试失败，状态->OPEN继续保持断闸状态



## Resilience4J - 轻量级容错框架

CircuitBreaker仅是一套规范和接口，真正的实现者是Resilience4J（轻量级容错框架）



### 几个核心模块

> 前三个重点，后三个凑数

- ⭐resilience4j-Circuitbreaker: 断路
- ⭐resilience4j-ratelimiter: 速率限制
- ⭐resilience4j-bulkhead: 舱壁
- resilience4j-retry: 自动重试（同步or异步） **（一般自己写）**
- resilience4j-timelimiter: 超时处理 **（有谷歌框架用）**
- resilience4j-cache: 结果缓存 **（肯定用redis！）**



### 中文指导手册仓库

[GitHub - lmhmhl/Resilience4j-Guides-Chinese: Resilience4j guides in chinese version](https://github.com/lmhmhl/Resilience4j-Guides-Chinese)



## 实战

### 熔断（CircuitBreaker） - 服务熔断 + 服务降级

#### 两种熔断方式

1. 按数量
2. 按时间



> **断路器的状态**

三个普通状态：关闭（CLOSED）、开启（OPEN）、半开（HALF_OPEN）

两个特殊状态：禁用（DISABLED）、强制开启（FORCED_OPEN）

- 熔断器关闭时，所有请求都会通过熔断器

  - 失败超过设定阈值，熔断器会打开，所有请求都会被拒绝
  - 经过一段时间后，熔断器会从打开状态转换到掰开状态，这时仅有一定数量额度请求会被放入，重新计算失败率
  - 如果失败率超过阈值，变为打开状态；低于阈值，变为关闭状态

- 断路器使用滑动窗口存储和统计调用的结果，可以选择基于调用数量的滑动窗口or基于时间的滑动窗口

  - 基于访问数量的滑动窗口统计最近N次调用的返回结果 COUNT_BASED
  - 基于时间的滑动窗口统计最近N秒调用的返回结果 TIME_BASED

- 两种特殊状态：DISALED（始终允许访问）、FORCED_OPEN（始终拒绝访问）

  - 这两个状态不会生成熔断器事件（除状态转换外），并且不会记录事件的成功or失败
  - 退出这两个状态的方法：触发状态转换 or 重置熔断器

  

**断路器配置参数参考**

| 配置属性                                     | 描述                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| failure-rate-threshold                       | 以百分比配置失败率峰值                                       |
| sliding-window-type                          | 断路器的滑动窗口期类型 可以基于“次数”（COUNT_BASED）或者“时间”（TIME_BASED）进行熔断，默认是COUNT_BASED。 |
| sliding-window-size                          | 若COUNT_BASED，则10次调用中有50%失败（即5次）打开熔断断路器； 若为TIME_BASED则，此时还有额外的两个设置属性，含义为：在N秒内（sliding-window-size）100%（slow-call-rate-threshold）的请求超过N秒（slow-call-duration-threshold）打开断路器。 |
| slowCallRateThreshold                        | 以百分比的方式配置，断路器把调用时间大于slowCallDurationThreshold的调用视为慢调用，当慢调用比例大于等于峰值时，断路器开启，并进入服务降级。 |
| slowCallDurationThreshold                    | 配置调用时间的峰值，高于该峰值的视为慢调用。                 |
| permitted-number-of-calls-in-half-open-state | 运行断路器在HALF_OPEN状态下时进行N次调用，如果故障或慢速调用仍然高于阈值，断路器再次进入打开状态。 |
| minimum-number-of-calls                      | 在每个滑动窗口期样本数，配置断路器计算错误率或者慢调用率的最小调用数。比如设置为5意味着，在计算故障率之前，必须至少调用5次。如果只记录了4次，即使4次都失败了，断路器也不会进入到打开状态。 |
| wait-duration-in-open-state                  | 从OPEN到HALF_OPEN状态需要等待的时间                          |

 

#### 需求模拟

- 6次访问中，当执行方法的失败率达到50%时，CircuitBreaker将进入开启OPEN状态（保险丝跳闸断电）拒绝所有请求
- 等待5s后，CircuitBreaker将自动从开启OPEN状态度过到半开HALF_OPEN状态，允许一些请求通过以测试服务是否恢复正常
- 如还是异常，CircuitBreaker将重新进入开启OPEN状态；如正常，将进入关闭CLOSE闭合状态，恢复正常处理请求

#### 相关面试题

项目中稳定性问题如何解决 - 熔断、降级...



#### 实战演练

> ##### **谨记：**
>
> 1. 仅启动一个提供者项目（如8001）
> 2. 启动一个消费者项目
> 3. 否则，容易因负载均衡，因8002中没有对应的接口，导致失败次数直接达到50%（按次数断路）
> 4. 解决方案：8002添加对应接口

**服务提供者中提供代码（会导致断路的方法）：**

```java
@RestController
public class PayCircuitController {
    //=========Resilience4j CircuitBreaker 的例子
    @GetMapping(value = "/pay/circuit/{id}")
    public String myCircuit(@PathVariable("id") Integer id) {
        if (id == -4) {
            throw new RuntimeException("----circuit id 不能负数");
        }
        if (id == 9999) {
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return "Hello, circuit! inputId:  " + id + " \t " + IdUtil.simpleUUID();
    }
}
```



**暴露该接口到注册中心**

```java
@FeignClient(value = "cloud-payment-service")
public interface PayFeignApi {
    @GetMapping(value = "/pay/circuit/{id}")
    public String myCircuit(@PathVariable("id") Integer id);
}
```



**给消费者引入断路器依赖**

```xml
<!--resilience4j-circuitbreaker-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
</dependency>
<!-- 由于断路保护等需要AOP实现，所以必须导入AOP包 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```



**在消费者中配置circuitbreaker**

- COUNT_BASED

```yaml
# 开启circuitbreaker和分组激活 spring.cloud.openfeign.circuitbreaker.enabled
circuitbreaker:
  enabled: true
  group:
    enabled: true #没开分组永远不用分组的配置。精确优先、分组次之(开了分组)、默认最后
```

```yaml
# Resilience4j CircuitBreaker 按照次数：COUNT_BASED 的例子
#  6次访问中当执行方法的失败率达到50%时CircuitBreaker将进入开启OPEN状态(保险丝跳闸断电)拒绝所有请求。
#  等待5秒后，CircuitBreaker 将自动从开启OPEN状态过渡到半开HALF_OPEN状态，允许一些请求通过以测试服务是否恢复正常。
#  如还是异常CircuitBreaker 将重新进入开启OPEN状态；如正常将进入关闭CLOSE闭合状态恢复正常处理请求。
resilience4j:
  circuitbreaker:
    configs:
      default:
        # 设置50%的调用失败时打开断路器，超过失败请求百分⽐CircuitBreaker变为OPEN状态。
        failureRateThreshold: 50
        # 滑动窗口的类型
        slidingWindowType: COUNT_BASED
        # 滑动窗⼝的⼤⼩配置COUNT_BASED表示6个请求，配置TIME_BASED表示6秒
        slidingWindowSize: 6
        # 断路器计算失败率或慢调用率之前所需的最小样本(每个滑动窗口周期)。
        # 如果minimumNumberOfCalls为10，则必须最少记录10个样本，然后才能计算失败率。
        # 如果只记录了9次调用，即使所有9次调用都失败，断路器也不会开启。
        minimumNumberOfCalls: 6
        # 是否启用自动从开启状态过渡到半开状态，默认值为true。
        # 如果启用，CircuitBreaker将自动从开启状态过渡到半开状态，并允许一些请求通过以测试服务是否恢复正常
        automaticTransitionFromOpenToHalfOpenEnabled: true
        # 从OPEN到HALF_OPEN状态需要等待的时间
        waitDurationInOpenState: 5s
        # 半开状态允许的最大请求数，默认值为10。
        # 在半开状态下，CircuitBreaker将允许最多permittedNumberOfCallsInHalfOpenState个请求通过
        # 如果其中有任何一个请求失败，CircuitBreaker将重新进入开启状态。
        permittedNumberOfCallsInHalfOpenState: 2
        recordExceptions:
          - java.lang.Exception
    instances:
      cloud-payment-service:
        baseConfig: default
```

**测试场景：**

1. 不停访问[localhost/feign/pay/circuit/11](http://localhost/feign/pay/circuit/11)，不断得到随机uuid

2. 访问两次[localhost/feign/pay/circuit/11](http://localhost/feign/pay/circuit/11)，再访问四次[localhost/feign/pay/circuit/-4](http://localhost/feign/pay/circuit/-4)

   因为-4是报错的，超过了百分之五十的出错概率，直接服务熔断

   5s后，将半开测试，判断最终是否恢复

   



- TIME_BASED

```yaml
resilience4j:
  timelimiter:
    configs:
      default:
        timeout-duration: 10s #神坑的位置，timelimiter 默认限制远程1s，超于1s就超时异常，配置了降级，就走降级逻辑
  circuitbreaker:
    configs:
      default:
        failureRateThreshold: 50 #设置50%的调用失败时打开断路器，超过失败请求百分⽐CircuitBreaker变为OPEN状态。
        slowCallDurationThreshold: 2s #慢调用时间阈值，高于这个阈值的视为慢调用并增加慢调用比例。
        slowCallRateThreshold: 30 #慢调用百分比峰值，断路器把调用时间⼤于slowCallDurationThreshold，视为慢调用，当慢调用比例高于阈值，断路器打开，并开启服务降级
        slidingWindowType: TIME_BASED # 滑动窗口的类型
        slidingWindowSize: 2 #滑动窗口的大小配置，配置TIME_BASED表示2秒
        minimumNumberOfCalls: 2 #断路器计算失败率或慢调用率之前所需的最小样本(每个滑动窗口周期)。
        permittedNumberOfCallsInHalfOpenState: 2 #半开状态允许的最大请求数，默认值为10。
        waitDurationInOpenState: 5s #从OPEN到HALF_OPEN状态需要等待的时间
        recordExceptions:
          - java.lang.Exception
    instances:
      cloud-payment-service:
        baseConfig: default
```

**测试场景：**

1. 连续四个页面访问[localhost/feign/pay/circuit/9999](http://localhost/feign/pay/circuit/9999)，会延迟5s

2. 再次访问/11，会服务降级，因为超过50%的访问记录超时了

   等待5s后恢复正常



**消费者端使用断路器**

- @CircuitBreaker：使用断路器
  - name：指定使用配置
  - fallbackMethod：指定回调方法

```java
@GetMapping(value = "/feign/pay/circuit/{id}")
@CircuitBreaker(name = "cloud-payment-service", fallbackMethod = "myCircuitFallback")
public String myCircuitBreaker(@PathVariable("id") Integer id){
    return payFeignApi.myCircuit(id);
}

//myCircuitFallback就是服务降级后的兜底处理方法
public String myCircuitFallback(Integer id,Throwable t) {
    // 这里是容错处理逻辑，返回备用结果
    return id + ",myCircuitFallback，系统繁忙，请稍后再试-----/(ㄒoㄒ)/~~";
}
```



### 隔离（Bulk Head）

- 限并发
- 依赖隔离&负载保护：用来限制对于下游服务的最大并发数量的限制

#### 两种隔离实现方式：

- SemaphoreBulkhead(信号量舱壁）
- FixedThreadPoolBulkhead(固定线程池舱壁）



#### 舱壁依赖

```xml
<!--resilience4j-bulkhead-->
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-bulkhead</artifactId>
</dependency>
```



#### 提供者新增接口

8001和8002都新增，否则负载均衡会导致错误判断有问题

```java
@RestController
@Slf4j
public class PayBulkheadController {
    @GetMapping(value = "/pay/bulkhead/{id}")
    public String myBulkhead(@PathVariable("id") Integer id) {
        if (id == -4) {
            throw new RuntimeException("----bulkhead id 不能-4");
        }
        if (id == 9999) {
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return "Hello【8001】, bulkhead! inputId:  " + id + " \t " + IdUtil.simpleUUID();
    }
}
```



#### 信号量舱壁

> **信号量舱壁（SemaphoreBulkhead）原理**
>
> 当信号量有空闲时，进入系统的请求会直接获取信号量并开始业务处理。
>
> 当信号量全被占用时，接下来的请求将会进入阻塞状态，SemaphoreBulkhead提供了一个阻塞计时器，
>
> 如果阻塞状态的请求在阻塞计时内无法获取到信号量则系统会拒绝这些请求。
>
> 若请求在阻塞计时内获取到了信号量，那将直接获取信号量并执行相应的业务处理。

##### YML配置

```yaml
resilience4j:
  bulkhead:
    configs:
      default:
        maxConcurrentCalls: 2 # 隔离允许并发线程执行的最大数量
        maxWaitDuration: 1s # 当达到并发调用数量时，新的线程的阻塞时间，我只愿意等待1秒，过时不候进舱壁兜底fallback
    instances:
      cloud-payment-service:
        baseConfig: default
  timelimiter:
    configs:
      default:
        timeout-duration: 20s
```

##### 消费者新增接口

- @Bulkhead：舱壁注解
  - name：服务名称
  - fallbackMethod：回调方法
  - type：隔离方式

```java
/**
 * (船的)舱壁,隔离 信号舱壁
 */
@GetMapping(value = "/feign/pay/bulkhead/semaphore/{id}")
@Bulkhead(name = "cloud-payment-service",fallbackMethod = "myBulkheadFallback",type = Bulkhead.Type.SEMAPHORE)
public String myBulkhead(@PathVariable("id") Integer id)
{
    return payFeignApi.myBulkhead(id);
}
public String myBulkheadFallback(Throwable t)
{
    return "myBulkheadFallback，隔板超出最大数量限制，系统繁忙，请稍后再试-----/(ㄒoㄒ)/~~";
}
```

**测试：**

请求1、2都访问/9999，需要等待5s

此时请求3访问/3，因为已经有两个并发线程了，他将等待1s，1s后没有执行就进行服务隔离

**踩坑：**

1. 设置openfeign的连接超时和读取超时时间为3s，而/9999需要等待5s，因此不论如何请求都是有问题的

2. circuitbreaker必须开启分组激活（circuitbreaker.group.enabled），否则/3就算没有并发槽也能访问成功

   ```yaml
   server:
     port: 80
   spring:
     application:
       name: cloud-consumer-openfeign-order
     cloud:
       openfeign:
         ...
         # 开启circuitbreaker和分组激活 spring.cloud.openfeign.circuitbreaker.enabled
         circuitbreaker:
           enabled: true
           group:
             enabled: true #没开分组永远不用分组的配置。精确优先、分组次之(开了分组)、默认最后
   ```





#### **固定线程池舱壁**

> **固定线程池舱壁（FixedThreadPoolBulkhead）**
>
> FixedThreadPoolBulkhead的功能与SemaphoreBulkhead一样也是**用于限制并发执行的次数**的
>
> 但是二者的实现原理存在差别而且表现效果也存在细微的差别
>
> FixedThreadPoolBulkhead使用**一个固定线程池**和**一个等待队列**来实现舱壁。
>
> - 当线程池中存在空闲时，则此时进入系统的请求将直接进入线程池开启新线程或使用空闲线程来处理请求。
> - 当线程池中无空闲时时，接下来的请求将进入等待队列，
>   - 若等待队列仍然无剩余空间时接下来的请求将直接被拒绝，
>   - 在队列中的请求等待线程池出现空闲时，将进入线程池进行业务处理。
> - 另外：ThreadPoolBulkhead只对CompletableFuture方法有效，所以我们必创建返回CompletableFuture类型的方法

##### 消费者新增接口

```java
@GetMapping(value = "/feign/pay/bulkhead/threadpool/{id}")
@Bulkhead(name = "cloud-payment-service", fallbackMethod = "myBulkheadPoolFallback", type = Bulkhead.Type.THREADPOOL)
public CompletableFuture<String> myBulkheadTHREADPOOL(@PathVariable("id") Integer id) {
    System.out.println(Thread.currentThread().getName() + "\t" + "enter the method!!!");
    try {
        TimeUnit.SECONDS.sleep(3);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println(Thread.currentThread().getName() + "\t" + "exist the method!!!");

    return CompletableFuture.supplyAsync(() -> payFeignApi.myBulkhead(id) + "\t" + " Bulkhead.Type.THREADPOOL");
}

public CompletableFuture<String> myBulkheadPoolFallback(Integer id, Throwable t) {
    return CompletableFuture.supplyAsync(() -> "【固定线程池舱壁】Bulkhead.Type.THREAD POOL，系统繁忙，请稍后再试-----/(ㄒoㄒ)/~~");
}
```



##### YML配置

```yaml
####resilience4j bulkhead -THREADPOOL的例子
resilience4j:
  timelimiter:
    configs:
      default:
        timeout-duration: 10s #timelimiter默认限制远程1s，超过报错不好演示效果所以加上10秒
  thread-pool-bulkhead:
    configs:
      default:
        core-thread-pool-size: 2
        max-thread-pool-size: 2
        queue-capacity: 2
    instances:
      cloud-payment-service:
        baseConfig: default
# spring.cloud.openfeign.circuitbreaker.group.enabled 请设置为false 新启线程和原来主线程脱离
```

依次请求/1、/2、/3、/4、/5

/1&/2等待3后输出，/3&/4在队列中，等待前面执行完就补上去，5直接降级（1&2在线程池中执行，3&4在排队，5就不允许进来了）

/3也会等/1执行完后再执行

**线程池隔离就是根据线程池已有的数量及队列数量进行判断，如果已满，将直接进行服务降级**



### 限并发和限流小插曲

- 限并发，是限制同一时刻可以执行的请求数量等..
- 限流，是限制一段时间内，可以接收的请求数量..

**====如：**

- 公园的总容量是3000人，这就是并发，多了无法执行；
- 公园下午四点到四点十分，一共只接纳20人，这就是限流
- 秒杀业务，瞬时大量请求过来，需限流



### 限流（RateLimiter）

#### 官网

- https://resilience4j.readme.io/docs/ratelimiter
- https://github.com/lmhmhl/Resilience4j-Guides-Chinese/blob/main/core-modules/ratelimiter.md

#### 概述

- 限制频率

- 常见的限流算法：

  - 漏斗算法（Leaky Bucket）

    <img src="D:\File\markdownPictures\image-20240724163417459.png" alt="image-20240724163417459" style="zoom:33%;" />

    **缺点：**这里有两个变量，一个是桶的大小，支持流量突发增多时可以存多少的水（burst），另一个是水桶漏洞的大小（rate）。因为漏桶的漏出速率是固定的参数，所以，即使网络中不存在资源冲突（没有发生拥塞），漏桶算法也不能使流突发（burst）到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率。

    <img src="D:\File\markdownPictures\image-20240724163259552.png" alt="image-20240724163259552" style="zoom:33%;" />

  - 令牌桶算法（Token Bucket）-SpringCloud默认算法

    **个人理解：**请求以什么频率来，不知道。但是提供令牌是均匀提供，并且总量一定，如果一瞬间令牌拿完了，没有令牌，也就限制住了。

    <img src="D:\File\markdownPictures\image-20240724170009606.png" alt="image-20240724170009606" style="zoom:33%;" />

  - 滚动时间窗（tumbling time window）

    没太理解，按时间段切割若干个用户请求的次数总和，超过固定值就将超过部分送去排队？

    缺点是，最大允许100，以一分钟为时间段切割的话，12:00:59来了100个请求，12:01:00到12:01:01又来了100个，刚好切割转换的时间节点，来了double倍，很crazy！

    <img src="D:\File\markdownPictures\image-20240725103034624.png" alt="image-20240725103034624" style="zoom:33%;" />

  - 滑动事件窗口（sliding time windows）

    <img src="D:\File\markdownPictures\image-20240725103054990.png" alt="image-20240725103054990" style="zoom:33%;" />





#### 快速开始

##### 提供者新增接口

```java
@GetMapping(value = "/pay/ratelimit/{id}")
public String myRatelimit(@PathVariable("id") Integer id)
{
    return "Hello, myRatelimit欢迎到来 inputId:  "+id+" \t " + IdUtil.simpleUUID();
}
```

##### 公共接口新增

```java
@GetMapping(value = "/pay/ratelimit/{id}")
public String myRatelimit(@PathVariable("id") Integer id);
```

##### 消费者新增限流依赖

```xml
<!--resilience4j-ratelimiter-->
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-ratelimiter</artifactId>
</dependency>
```

##### 消费者新增配置文件

```yml
####resilience4j ratelimiter 限流的例子
resilience4j:
  ratelimiter:
    configs:
      default:
        limitForPeriod: 2 #在一次刷新周期内，允许执行的最大请求数
        limitRefreshPeriod: 1s # 限流器每隔limitRefreshPeriod刷新一次，将允许处理的最大请求数量重置为limitForPeriod
        timeout-duration: 1 # 线程等待权限的默认等待时间
    instances:
        cloud-payment-service:
          baseConfig: default
```

##### 消费者新增接口

```java
@GetMapping(value = "/feign/pay/ratelimit/{id}")
@RateLimiter(name = "cloud-payment-service",fallbackMethod = "myRatelimitFallback")
public String myBulkhead(@PathVariable("id") Integer id){
    return payFeignApi.myRatelimit(id);
}
public String myRatelimitFallback(Integer id,Throwable t){
    return "你被限流了，禁止访问/(ㄒoㄒ)/~~";
}
```

##### 效果

[localhost/feign/pay/ratelimit/11](http://localhost/feign/pay/ratelimit/11)

1s内连续点击三次如上链接，第三次会被限流~



# Sleuth（Micrometer）分布式链路追踪

## Sleuth进入维护状态..

替换方案：Micrometer Tracing

Sleuth不适用于SpringBoot3.x+，主要支持SpringBoot2.x+



## 前情提要

![image-20240725114427080](D:\File\markdownPictures\image-20240725114427080.png)



## 概述

### 官网 

- micrometer：

  https://micrometer.io/docs/tracing

- sleuth：

  https://spring.io/projects/spring-cloud-sleuth#overview

  https://github.com/spring-cloud/spring-cloud-sleuth

### ZipKin？

Spring Cloud Sleuth（Micrometer）提供分布式链路追踪，支持使用ZipKin展现

<img src="D:\File\markdownPictures\image-20240725135048573.png" alt="image-20240725135048573" style="zoom:33%;" />

### 小结

Spring Cloud Sleuth提供一次分布式请求的完整链路追踪，进行日志记录和性能监控

并将调用情况集中以Web展示

**行业内其他成熟解决方案：**

<img src="D:\File\markdownPictures\image-20240725135425726.png" alt="image-20240725135425726" style="zoom:33%;" />



## 简单原理展示

<img src="D:\File\markdownPictures\image-20240725145227248.png" alt="image-20240725145227248" style="zoom:33%;" />

> 那么一条链路追踪会在每个服务调用的时候加上Trace ID 和 Span ID
>
> 链路通过TraceId唯一标识，
>
> Span标识发起的请求信息，各span通过parent id 关联起来 (Span:表示调用链路来源，通俗的理解span就是一次请求信息)

<img src="D:\File\markdownPictures\image-20240725145116502.png" alt="image-20240725145116502" style="zoom:40%;" />





# ZipKin

## 概述

Zipkin是一种分布式链路跟踪系统图形化的工具，Zipkin 是 Twitter 开源的分布式跟踪系统，能够收集微服务运行过程中的实时调用链路信息，并能够将这些调用链路信息展示到Web图形化界面上供开发人员分析，开发人员能够从ZipKin中分析出调用链路中的性能瓶颈，识别出存在问题的应用程序，进而定位问题和解决问题。

**官网：** [OpenZipkin ·分布式追踪系统](https://zipkin.io/)

启动后访问（端口9411）：[Zipkin](http://localhost:9411/zipkin/)



# Micrometer & ZipKin

- Micrometer：数据采样
- ZipKin：图形展示

```xml
<properties>
    <micrometer-tracing.version>1.2.0</micrometer-tracing.version>
    <micrometer-observation.version>1.12.0</micrometer-observation.version>
    <feign-micrometer.version>12.5</feign-micrometer.version>
    <zipkin-reporter-brave.version>2.17.0</zipkin-reporter-brave.version>
</properties>

<dependencyManagement>
    <dependencies>
        <!--micrometer-tracing-bom导入链路追踪版本中心  1-->
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-tracing-bom</artifactId>
            <version>${micrometer-tracing.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <!--micrometer-tracing指标追踪  2-->
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-tracing</artifactId>
            <version>${micrometer-tracing.version}</version>
        </dependency>
        <!--micrometer-tracing-bridge-brave适配zipkin的桥接包 3-->
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-tracing-bridge-brave</artifactId>
            <version>${micrometer-tracing.version}</version>
        </dependency>
        <!--micrometer-observation 4-->
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-observation</artifactId>
            <version>${micrometer-observation.version}</version>
        </dependency>
        <!--feign-micrometer 5-->
        <dependency>
            <groupId>io.github.openfeign</groupId>
            <artifactId>feign-micrometer</artifactId>
            <version>${feign-micrometer.version}</version>
        </dependency>
        <!--zipkin-reporter-brave 6-->
        <dependency>
            <groupId>io.zipkin.reporter2</groupId>
            <artifactId>zipkin-reporter-brave</artifactId>
            <version>${zipkin-reporter-brave.version}</version>
        </dependency>
    </dependencies>
</dependencyManagement>
```

## 依赖爆红超级牛逼解决方案

去掉dependencyManagement，重新引入下载到本地，再加上dependencyManagement

## 继续

由于Micrometer Tracing是一个门面工具自身并没有实现完整的链路追踪系统，具体的链路追踪另外需要引入的是第三方链路追踪系统的依赖：

[![pkOiukR.png](https://s21.ax1x.com/2024/07/30/pkOiukR.png)](https://imgse.com/i/pkOiukR)



**补充包：** spring-boot-starter-actuator  SpringBoot框架的一个模块用于监视和管理应用程序



## 启动

1. 访问 http://localhost/feign/micrometer/80
2. 进入 http://localhost:9411/zipkin 查看链路



# Gateway网关

有Nginx，为什么还需要Gateway？

## 概述

- 官网：https://docs.spring.io/spring-cloud-gateway/docs/4.0.4/reference/html/

- Gateway是在Spring生态系统之上构建的API网关服务，基于Spring6，Spring Boot 3和Project Reactor等技术。它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式，并为它们提供跨领域的关注点，例如：安全性、监控/度量和恢复能力。

- [![pkOFG80.png](https://s21.ax1x.com/2024/07/30/pkOFG80.png)](https://imgse.com/i/pkOFG80)

- Cloud全家桶中有个很重要的组件就是网关，在1.x版本中都是采用的Zuul网关；

  但在2.x版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关SpringCloud Gateway替代Zuul，

  那就是SpringCloud Gateway一句话：gateway是原zuul1.x版的替代

### 作用

- 反向代理
- 鉴权
- 流量控制
- 熔断
- 日志监控



### 小结

- Spring Cloud Gateway组件的核心是一系列的过滤器，通过这些过滤器可以将客户端发送的请求转发(路由)到对应的微服务。 
- Spring Cloud Gateway是加在整个微服务最前沿的防火墙和代理器，隐藏微服务结点IP端口信息，从而加强安全保护。
- Spring Cloud Gateway本身也是一个微服务，需要注册进服务注册中心。

[![pkOFNKU.png](https://s21.ax1x.com/2024/07/30/pkOFNKU.png)](https://imgse.com/i/pkOFNKU)





















## 三大核心

- **Route(路由)**

  路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由

- **Predicate(断言)**

  参考的是Java8的java.util.function.Predicate

  开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，**如果请求与断言相匹配则进行路由**

- **Filter(过滤)**

  指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。



## 工作流程

- 客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。
- 过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(Pre)或之后(Post)执行业务逻辑。
- 在“pre”类型的过滤器可以做**参数校验、权限校验、流量监控、日志输出、协议转换等;**
- 在“post”类型的过滤器中可以做**响应内容、响应头的修改，日志的输出，流量监控**等有着非常重要的作用。

### 核心逻辑

路由转发+断言判断+执行过滤器链



## 快速开始 - 准备工作

首先一点，网关是一个单独的工程

新建工程 New Module

### POM

```xml
<dependencies>
    <!--gateway-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    <!--服务注册发现consul discovery,网关也要注册进服务注册中心统一管控-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-consul-discovery</artifactId>
    </dependency>
    <!-- 指标监控健康检查的actuator,网关是响应式编程删除掉spring-boot-starter-web dependency-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
</dependencies>
```



### YAML

```yaml
server:
  port: 9527

spring:
  application:
    name: cloud-gateway #以微服务注册进consul或nacos服务列表内
  cloud:
    consul: #配置consul地址
      host: localhost
      port: 8500
      discovery:
        prefer-ip-address: true
        service-name: ${spring.application.name}
```



### MAINAPPLICATION（启动类）

```java
@SpringBootApplication
@EnableDiscoveryClient //服务注册和发现
public class Main9527 {
    public static void main(String[] args) {
        SpringApplication.run(Main9527.class, args);
    }
}
```



### 业务类

网关与业务无关



## 快速开始 - 开写！

[![pkOAJnU.md.png](https://s21.ax1x.com/2024/07/30/pkOAJnU.md.png)](https://imgse.com/i/pkOAJnU)

















**诉求：** 不想暴露真实的提供者端口，即8001。希望外面套一层9527网关

原本访问8001测试接口路径：http://localhost:8001/pay/gateway/info

添加网关配置后访问路径：http://localhost:9527/pay/gateway/info

说明8001前添加微服务成功！

配置如下：

```yaml
server:
  port: 9527
spring:
  cloud:
    ...
    gateway:
      routes:
        - id: pay_routh1 #pay_routh1                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001                #匹配后提供服务的路由地址
          predicates:
            - Path=/pay/gateway/get/**              # 断言，路径相匹配的进行路由

        - id: pay_routh2 #pay_routh2                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名
          uri: http://localhost:8001                #匹配后提供服务的路由地址
          predicates:
            - Path=/pay/gateway/info/**              # 断言，路径相匹配的进行路由
```



现在要做到，启动80订单微服务，能通过consul注册中心，通过微服务名称找到8001支付微服务进行调用

80 -> 9527 -> 8001

### 问题

消费者中编写了调用的接口，网关关闭or开启都不影响是否调用成功

绕开了网关的原因是？

消费者调用的接口直接是提供者的，而非走网关

修改消费者调用接口的服务名`@FeignClient(value = "cloud-gateway")`

此时，如果网关服务不启动，不注册到注册中心，将报错：

```bash
Caused by: feign.FeignException$ServiceUnavailable: [503] during [GET] to [http://cloud-gateway/pay/gateway/info] [PayFeignApi#getGatewayInfo()]: [Load balancer does not contain an instance for the service cloud-gateway]
```





## Gateway高级特性

### Route以微服务名，动态获取服务URI

#### 此前网关配置问题

[<img src="https://s21.ax1x.com/2024/08/05/pkvQwNt.png" alt="pkvQwNt.png" style="zoom: 67%;" />](https://imgse.com/i/pkvQwNt)



















直接结合注册中心的服务名，一个名字下面可以存在多个端口的相同服务

#### 新配置格式

```yaml
gateway:
	routes:
		- id: pay_routh1 #pay_routh1                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名
		  uri: lb://cloud-payment-service                #匹配后提供服务的路由地址
		  predicates:
			- Path=/pay/gateway/get/**              # 断言，路径相匹配的进行路由

		- id: pay_routh2 #pay_routh2                #路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名
		  uri: lb://cloud-payment-service              #匹配后提供服务的路由地址
		  predicates:
			- Path=/pay/gateway/info/**              # 断言，路径相匹配的进行路由
```



### Predicate断言（谓词）

#### 常用内置Route Predicate

- **官网**

  https://docs.spring.io/spring-cloud-gateway/reference/spring-cloud-gateway/configuring-route-predicate-factories-and-filter-factories.html

- **两种配置二选一：**

  - Shortcut Configuration

    ```yaml
    spring:
      cloud:
        gateway:
          routes:
          - id: after_route
            uri: https://example.org
            predicates:
            - Cookie=mycookie,mycookievalue
    ```

  - Fully Expanded Arguments

    ```yaml
    spring:
      cloud:
        gateway:
          routes:
          - id: after_route
            uri: https://example.org
            predicates:
            - name: Cookie
              args:
                name: mycookie
                regexp: mycookievalue
    ```

#### 常用断言API

id：自定义路由的ID，保持唯一

uri：服务地址

predicates：路由条件，Predicate接收一个输入参数返回一个布尔值

​			该属性包含多种默认方法来将Predicate组合成其他复杂的逻辑（与、或、非）

#### After / Before / Between  Route Predicate

使用时间格式**ZonedDateTime**，配置如下

表明，在2024.08.05 01:28:39之后才能访问该路由

```yaml
predicates:
  - Path=/pay/gateway/get/**              # 断言，路径相匹配的进行路由
  - After = 2024-08-05T01:28:39.362106800+08:00[Asia/Hong_Kong]
```

ZonedDateTime获取方式

```java
// 默认时区
ZonedDateTime zbj = ZonedDateTime.now();
System.out.println(zbj);
```



#### Cookie Route Predicate

> Cookie Route Predicate需要两个参数，一个是 Cookie name ,一个是正则表达式。
>
> 路由规则会通过获取对应的 Cookie name 值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行

```yaml
predicates:
  - Path=/pay/gateway/get/**              # 断言，路径相匹配的进行路由
  - Cookie=username,cdd
```



#### ...

Header、Host、Path、Query、RemoteAddr、Method

- **Header**

  两个参数：一个是属性名称和一个正则表达式，这个属性值和正则表达式匹配则执行。

- **Host**

  Host Route Predicate 接收一组参数，一组匹配的域名列表，这个模板是一个 ant 分隔的模板，用.号作为分隔符。

  它通过参数中的主机地址作为匹配规则

- **Query**

  支持传入两个参数，一个是属性名，一个为属性值，属性值可以是正则表达式。

- **RemoteAddr**

  [<img src="https://s21.ax1x.com/2024/08/05/pkvQz8K.png" alt="pkvQz8K.png" style="zoom: 50%;" />](https://imgse.com/i/pkvQz8K)









```yaml
predicates:
	- Path=/pay/gateway/get/**              # 断言，路径相匹配的进行路由
	- After=2023-11-20T17:38:13.586918800+08:00[Asia/Shanghai]
	- Before=2023-12-29T17:58:13.586918800+08:00[Asia/Shanghai]
	- Between=2023-11-21T17:38:13.586918800+08:00[Asia/Shanghai],2023-11-22T17:38:13.586918800+08:00[Asia/Shanghai]
	- Cookie=username,zzyy
    - Header=X-Request-Id, \d+  # 请求头要有X-Request-Id属性并且值为整数的正则表达式
    - Host=**.atguigu.com
    - Query=username, \d+  # 要有参数名username并且值还要是整数才能路由
    - RemoteAddr=192.168.124.1/24 # 外部访问我的IP限制，最大跨度不超过32，目前是1~24它们是 CIDR 表示法。
    - Method=GET,POST
```

#### 小结

Predicate就是为了实现一组匹配规则，让请求过来找到对应的Route进行处理。



#### 自定义断言

XxxRoutePredicateFactory规则





### Filter过滤

#### 概述

官网

https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories

≈ Spring MVC中的拦截器

作用

1. 请求鉴权
2. 异常处理（有异常就重定向）
3. 记录接口调用时长统计



过滤器类型

1. 全局默认过滤器Global Filters

   出厂默认，直接作用于所有路由；不需要在配置文件中配置，实现GlobalFilter即可

2. 单一内置过滤器Gateway Filters

   网关过滤器，主要作用于单一路由或某个路由分组

3. 自定义过滤器

#### 全局默认过滤器Global Filters

官网文档：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#global-filters

很少使用，略..



#### 单一内置过滤器Gateway Filter

官网文档：https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories

##### 部分配置

**- 请求头篇**

```yaml
- id: pay_routh3 #pay_routh3
  uri: lb://cloud-payment-service                #匹配后提供服务的路由地址
  predicates:
    - Path=/pay/gateway/filter/**              # 断言，路径相匹配的进行路由
  filters:
    - AddRequestHeader=X-Request-xxx1,xxx1  # 请求头kv，若一头含有多参则重写一行设置
    - AddRequestHeader=X-Request-xxx2,xxx2
```



**- 请求参数篇**

```yaml
filters:
  - AddRequestParameter=customerId,9527001 # 新增请求参数Parameter：k ，v
  - RemoveRequestParameter=customerName   # 删除url请求参数customerName，你传递过来也是null
```



**- 响应头篇**

... 其他情况，请参考gitee提交记录



#### 全局通用配置

**格式如下：**

[![pkxQyyF.png](https://s21.ax1x.com/2024/08/06/pkxQyyF.png)](https://imgse.com/i/pkxQyyF)





#### 自定义全局过滤器

统计接口调用耗时情况，谈谈设计思路：





# SpringCloud Alibaba

## 概述

官方文档：

[spring-cloud-alibaba/README-zh.md at 2023.x · alibaba/spring-cloud-alibaba · GitHub](https://github.com/alibaba/spring-cloud-alibaba/blob/2023.x/README-zh.md)



- **Sentinel**

  把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性

- **Nacos**

  动态服务发现、配置管理和服务管理平台

- **Seata**

  微服务分布式事务解决方案

上述主要使用，SpringCloudAlibaba其他组件：

- Rocket
- Alibaba Cloud OSS
- Alibaba Cloud SchedulerX
- Alibaba Cloud SMS



[![pkxdRTf.png](https://s21.ax1x.com/2024/08/06/pkxdRTf.png)](https://imgse.com/i/pkxdRTf)























## 文档地址

### 版本说明

https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E



### 参考文档

https://spring-cloud-alibaba-group.github.io/github-pages/2022/zh-cn/2022.0.0.0-RC2.html





# Nacos - 服务注册和配置中心

## 概述

[Nacos官网| Nacos 配置中心 | Nacos 下载| Nacos 官方社区 | Nacos 官网](https://nacos.io/)

一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台

Nacos = Eureka + Config + Bus（Eureka注册中心，Config+Bus服务配置中心，满足动态刷新广播通知）

= Spring Cloud Consul

[<img src="https://s21.ax1x.com/2024/08/06/pkxwe9e.png" alt="pkxwe9e.png" style="zoom:50%;" />](https://imgse.com/i/pkxwe9e)















[<img src="https://s21.ax1x.com/2024/08/06/pkxwIUK.png" alt="pkxwIUK.png" style="zoom: 50%;" />](https://imgse.com/i/pkxwIUK)













## 快速开始（服务者和消费者）

1. 安装

2. 启动

   bin目录下执行`startup.cmd -m standalone`

3. 页面

   http://localhost:8848/nacos

4. 中文参考文档（2022）

   https://spring-cloud-alibaba-group.github.io/github-pages/2022/zh-cn/2022.0.0.0-RC2.html
   
5. 新建服务提供者：

   **依赖（nacos依赖）**

   ```xml
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```

   **配置**

   ```yaml
   server:
     port: 9001
   spring:
     application:
       name: nacos-payment-provider
     cloud:
       nacos:
         discovery:
           #配置Nacos地址
           server-addr: localhost:8848
   ```

   **启动类**

   ```java
   @SpringBootApplication
   @EnableDiscoveryClient
   public class Main9001 {
       public static void main(String[] args) {
           SpringApplication.run(Main9001.class, args);
       }
   }
   ```

6. 新建服务消费者

   **依赖**

   ```xml
   <!--nacos-discovery-->
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   <!--loadbalancer-->
   <dependency>
       <groupId>org.springframework.cloud</groupId>
       <artifactId>spring-cloud-starter-loadbalancer</artifactId>
   </dependency>
   ```

   **配置项**

   ```yaml
   server:
     port: 83
   spring:
     application:
       name: nacos-order-consumer
     cloud:
       nacos:
         discovery:
           server-addr: localhost:8848
   #消费者将要去访问的微服务名称(nacos微服务提供者叫什么你写什么)
   service-url:
     nacos-user-service: http://nacos-payment-provider
   ```

   **启动类**

   ```java
   @EnableDiscoveryClient
   @SpringBootApplication
   public class Main83 {
       public static void main(String[] args) {
           SpringApplication.run(Main83.class, args);
       }
   }
   ```



## Nacos作配置中心

官方文档

[Spring Cloud Alibaba 参考文档 (spring-cloud-alibaba-group.github.io)](https://spring-cloud-alibaba-group.github.io/github-pages/2022/zh-cn/2022.0.0.0-RC2.html#_spring_cloud_alibaba_nacos_config)



### 实现外部化部署

#### **依赖** 

配置中心所需配置如下，当然在Nacos体系中还需要被注册中心发现，因此至少需要引入nacos-discovery的依赖

```xml
<!--bootstrap-->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bootstrap</artifactId>
</dependency>
<!--nacos-config-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
```



#### **配置文件** 

需要两个配置文件：bootstrap.yml和application.yml

- bootstrap.yml

```yaml
# nacos配置
spring:
  application:
    name: nacos-config-client
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848 #Nacos服务注册中心地址
      config:
        server-addr: localhost:8848 #Nacos作为配置中心地址
        file-extension: yaml #指定yaml格式的配置
		group: PROD_GROUP #不写默认按照DEFAULT来
# nacos端配置文件DataId的命名规则是：
# ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}
# 本案例的DataID是:nacos-config-client-dev.yaml
```



- application.yml

```yml
server:
  port: 3377
spring:
  profiles:
    active: dev # 表示开发环境
       #active: prod # 表示生产环境
       #active: test # 表示测试环境
```



#### **主启动**

```java
@EnableDiscoveryClient
@SpringBootApplication
public class NacosConfigClient3377 {
    public static void main(String[] args) {
        SpringApplication.run(NacosConfigClient3377.class, args);
    }
}
```



#### **业务类**

> 通过Spring Cloud原生注解 **@RefreshScope** 实现配置自动更新

```java
@RestController
@RefreshScope //在控制器类加入@RefreshScope注解使当前类下的配置支持Nacos的动态刷新功能。
public class NacosConfigClientController {
    @Value("${config.info}")
    private String configInfo;

    @GetMapping("/config/info")
    public String getConfigInfo() {
        return configInfo;
    }
}
```



#### Nacos添加配置信息

官网

https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html

> 在 Nacos Spring Cloud 中，**`dataId`** 的完整格式如下：
>
> ```plain
> ${prefix}-${spring.profiles.active}.${file-extension}
> ```
>
> - **`prefix`** 默认为**`spring.application.name`**的值，也可以通过配置项 **`spring.cloud.nacos.config.prefix`**来配置。
> - **`spring.profiles.active`** 即为当前环境对应的 profile，详情可以参考 [Spring Boot文档](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles)。 **注意：当 `spring.profiles.active` 为空时，对应的连接符 `-` 也将不存在，dataId 的拼接格式变成 `${prefix}.${file-extension}`**
> - **`file-exetension` **为配置内容的数据格式，可以通过配置项 **`spring.cloud.nacos.config.file-extension`** 来配置。目前只支持 **`properties`** 和 **`yaml`** 类型。



#### 多环境多项目管理

> **问题1：**
>
> 实际开发中，通常一个系统会准备
>
> dev开发环境
>
> test测试环境
>
> prod生产环境。
>
> 如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢？
>
>  
>
> **问题2：**
>
> 一个大型分布式微服务系统会有很多微服务子项目，
>
> 每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境......
>
> 那怎么对这些微服务配置进行分组和命名空间管理呢？

Nacos架构文档：[Nacos 架构](https://nacos.io/zh-cn/docs/architecture.html)

<img src="https://cdn.nlark.com/yuque/0/2019/jpeg/338441/1561217857314-95ab332c-acfb-40b2-957a-aae26c2b5d71.jpeg" alt="nacos_data_model" style="zoom:50%;" />





# Sentinel - 熔断与限流

## 概述

**官网**

[home | Sentinel (sentinelguard.io)](https://sentinelguard.io/zh-cn/)

> **From 官网：**
>
> 随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。



## 快速开始

### 启动sentinel

- sentinel-1.8.6下载链接

  https://github.com/alibaba/Sentinel/releases/download/1.8.6/sentinel-dashboard-1.8.6.jar

- 直接java -jar运行

- 默认8080端口，账号密码默认sentinel

- sentinel服务启动成功！！！



### 创建一个被sentinel管理的服务

#### 1. 依赖

```xml
<!--SpringCloud alibaba sentinel -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
```

#### 2. 配置文件

```yaml
server:
  port: 8401
spring:
  application:
    name: cloudalibaba-sentinel-service
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848         #Nacos服务注册中心地址
    sentinel:
      transport:
        dashboard: localhost:8080 #配置Sentinel dashboard控制台服务地址
        port: 8719 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口
```

#### 3. 其他注意事项

- 启动类上加上nacos discover注解
- 编写两个接口模拟业务类
- 启动...

#### Next

按照如上步骤创建完毕后，访问sentinel控制台是空的

因为sentinel采用的是懒加载，需要手动访问一次相关接口，令sentinel检测到



## 流量控制（限流） - 流控模式

文档：[flow-control | Sentinel (sentinelguard.io)](https://sentinelguard.io/zh-cn/docs/flow-control.html)

- 直接
- 关联
- 链路

### 根据调用方限流 - 直接（默认）

当某个接口的 **QPS / 并发线程数** 达到某个阈值

将拒绝新的请求进入



### 具有关系的资源流量控制：关联流量控制

> **为A资源绑定B资源，当B资源触发到某个阈值的时候，需要对A资源进行限流**
>
> （两者存在资源争抢关系or依赖关系，就可以具备关联）
>

**案例：**

用户操作订单的场景中，需调用订单更新操作（写）和订单查询操作（读）

写入优先级 > 读取优先级，当写入操作达到阈值时，需对查询操作进行限流

限流生效时，订单（B）更新可以正常访问，查询（A）会触发限流提示

**作用：**

资源争抢关系：防止优先级低的操作影响到优先级高的操作

上下游（依赖）关系：...



### 根据调用链路入口限流：链路限流

> **来自不同链路的请求，对同一个目标访问的时候，实施针对性的不同限流措施**
>
> 如：C请求来访问就限流，D请求来访问OK
>
> /testC和/testD访问同一个service，达到阈值后，对C限流，不影响D

#### 模拟

1. 新增service.common()

   ```java
   @Service
   public class FlowLimitService {
       @SentinelResource(value = "common")
       public void common() {
           System.out.println("------FlowLimitService come in");
       }
   }
   ```

2. 新增testC、testD接口，调用common

   ```java
   @Resource
   private FlowLimitService flowLimitService;
   
   @GetMapping("/testC")
   public String testC() {
       flowLimitService.common();
       return "------testC";
   }
   @GetMapping("/testD")
   public String testD() {
       flowLimitService.common();
       return "------testD";
   }
   ```

3. 新增配置项

   > Sentinel默认会将Controller方法做context整合，导致链路模式的流控失效
   >
   > 需要修改application.yml，添加配置 web-context-unify: false ，表示关闭

   ```yaml
   # controller层的方法对service层调用不认为是同一个根链路
   spring.cloud.sentinel. web-context-unify: false 
   ```

4. sentinel控制台中配置

   [<img src="https://s21.ax1x.com/2024/08/12/pAp81iQ.png" alt="pAp81iQ.png" style="zoom: 33%;" />](https://imgse.com/i/pAp81iQ)

























## 流量控制（限流） - 流控效果

- 快速失败

- 预热Warm Up

  [限流 冷启动 · alibaba/Sentinel Wiki · GitHub](https://github.com/alibaba/Sentinel/wiki/限流---冷启动)

  **公式：** 阈值除以冷却因子coldFactor（默认值为3），经过预热时长后才会达到阈值

  **案例：** 5s后峰值达到10

  <img src="D:\File\markdownPictures\image-20240812145756528.png" alt="image-20240812145756528" style="zoom:33%;" />

  **应用场景：** 秒杀业务开始的瞬间会有很多流量上来，可能会把系统打死，一开始服务器接受少量请求，当预热了一定时间后，允许接受峰值的请求

  > 大白话来讲，刚开始把 阈值调低，不要让过多的请求访问服务器，导致冲垮服务器，先让服务器一点一点处理，再慢慢加量。经典的例子：一个好久没运动的人，你刚开始让他跑10圈，他可能会累死，但是你给他一个预热时间，比如 第一天跑 2圈，第三天跑 3 圈，第四天跑4圈，以此类推...
  >
  > 引自：[sentinel 控制台讲解-流控规则--流控效果:Warm Up(预热)_sentinel warm up-CSDN博客](https://blog.csdn.net/qq_41712271/article/details/118336309)

- 排队等待





## 熔断降级

### 熔断策略

> 在统计时长内，请求数量>最小请求数时，开始计算比例阈值
>
> 如果慢调用比例/异常比例，达到比例阈值，就进入熔断（异常数同理）
>
> 熔断时间达到熔断时长后，开始新的请求尝试（半开状态）

1. 慢调用比例

[<img src="https://s21.ax1x.com/2024/08/12/pApJ25D.png" alt="pApJ25D.png" style="zoom:50%;" />](https://imgse.com/i/pApJ25D)



















\

2. 异常比例 ...
3. 异常数 ... 



## 限流之 - @SentinelResource

**源码**

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
public @interface SentinelResource {

    //资源名称
    String value() default "";

    //entry类型，标记流量的方向，取值IN/OUT，默认是OUT
    EntryType entryType() default EntryType.OUT;
    //资源分类
    int resourceType() default 0;

    //处理BlockException的函数名称,函数要求：
    //1. 必须是 public
    //2.返回类型 参数与原方法一致
    //3. 默认需和原方法在同一个类中。若希望使用其他类的函数，可配置blockHandlerClass ，并指定blockHandlerClass里面的方法。
    String blockHandler() default "";

    //存放blockHandler的类,对应的处理函数必须static修饰。
    Class<?>[] blockHandlerClass() default {};

    //用于在抛出异常的时候提供fallback处理逻辑。 fallback函数可以针对所
    //有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。函数要求：
    //1. 返回类型与原方法一致
    //2. 参数类型需要和原方法相匹配
    //3. 默认需和原方法在同一个类中。若希望使用其他类的函数，可配置fallbackClass ，并指定fallbackClass里面的方法。
    String fallback() default "";

    //存放fallback的类。对应的处理函数必须static修饰。
    String defaultFallback() default "";

    //用于通用的 fallback 逻辑。默认fallback函数可以针对所有类型的异常进
    //行处理。若同时配置了 fallback 和 defaultFallback，以fallback为准。函数要求：
    //1. 返回类型与原方法一致
    //2. 方法参数列表为空，或者有一个 Throwable 类型的参数。
    //3. 默认需要和原方法在同一个类中。若希望使用其他类的函数，可配置fallbackClass ，并指定 fallbackClass 里面的方法。
    Class<?>[] fallbackClass() default {};


    //需要trace的异常
    Class<? extends Throwable>[] exceptionsToTrace() default {Throwable.class};

    //指定排除忽略掉哪些异常。排除的异常不会计入异常统计，也不会进入fallback逻辑，而是原样抛出。
    Class<? extends Throwable>[] exceptionsToIgnore() default {};
}
```



**按资源名限流，使用自定义返回信息**

sentinel中新增流控信息，资源名要填写注解中的value值，否则无法生效。

不可以填写路径！

```java
@GetMapping("/rateLimit/byResource")
@SentinelResource(value = "byResourceSentinelResource", blockHandler = "handleException")
public String byResource() {
    return "按资源名称SentinelResource限流测试OK";
}

public String handleException(BlockException exception) {
    return "服务不可用@SentinelResource启动" + "\t" + "o(╥﹏╥)o";
}
```





**按资源名限流，使用自定义返回信息 + 服务降级处理**

```java
@GetMapping("/rateLimit/doAction/{p1}")
@SentinelResource(value = "doActionSentinelResource",
                  blockHandler = "doActionBlockHandler", fallback = "doActionFallback")
public String doAction(@PathVariable("p1") Integer p1) {
    if (p1 == 0) {
        throw new RuntimeException("p1等于零直接异常");
    }
    return "doAction";
}

public String doActionBlockHandler(@PathVariable("p1") Integer p1, BlockException e) {
    log.error("sentinel配置自定义限流了:{}", e);
    return "sentinel配置自定义限流了";
}

public String doActionFallback(@PathVariable("p1") Integer p1, Throwable e) {
    log.error("程序逻辑异常了:{}", e);
    return "程序逻辑异常了" + "\t" + e.getMessage();
}
```

如果配置限流，超过阈值只是返回自定义信息

如果配置的限流中发生了异常，那么将跳过自定义限流信息，直接调用fallback回滚方法

当然刚如果也达到了阈值，也会返回自定义信息

限流 ＞ 异常，都限流了，肯定执行不到异常啦



# Sentinel - 热点与授权

## 热点

[热点参数限流 · alibaba/Sentinel Wiki (github.com)](https://github.com/alibaba/Sentinel/wiki/热点参数限流)

热点 = 经常访问，即统计或限制某个热点数据中访问频次最高的Top K数据

希望对热点数据访问进行限流或其他操作

> **引用：**
>
> 何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：
>
> - 商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制
> - 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制
>
> 热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。

在sentinel控制台中，设置热点限制

需要填入参数，0表示第一个参数，1表示第二个参数，以此类推

如果配置热点，第一个参数达到阈值后，此后只要携带第一个参数的请求就会被限流

### 参数例外项

假设参数一设置热点限制，我们希望在参数一等于一个特殊值的时候

原本的热点限制失效，出现例外操作。限流值和平时不同

如：参数一的值为778的时候，阈值可以达到200或其他..







## 授权

官网：[黑白名单控制 · alibaba/Sentinel Wiki (github.com)](https://github.com/alibaba/Sentinel/wiki/黑白名单控制)

需要根据调用接口的来源判断是否允许执行本次请求

提供黑、白名单两种授权类型，分别对应禁止与放行

1. 添加不知道什么玩意的处理器

   ```java
   @Component
   public class MyRequestOriginParser implements RequestOriginParser {
       @Override
       public String parseOrigin(HttpServletRequest httpServletRequest) {
           return httpServletRequest.getParameter("serverName");
       }
   }
   ```

2. 然后添加授权规则，如下：

   此时如果访问`/empower?serverName=a`，将会被拦截

   [<img src="https://s21.ax1x.com/2024/08/13/pApsBxf.png" alt="pApsBxf.png" style="zoom: 50%;" />](https://imgse.com/i/pApsBxf)















# Sentinel - 规则持久化

## 问题

重启微服务，原配置都将消失、失效



## 解决方法

限流配置规则持久化到Nacos保存

### 步骤

1. 依赖

   ```xml
   <!--SpringCloud ailibaba sentinel-datasource-nacos -->
   <dependency>
       <groupId>com.alibaba.csp</groupId>
       <artifactId>sentinel-datasource-nacos</artifactId>
   </dependency>
   ```

2. 配置文件 - 配置spring.cloud.sentinel.datasource

   ```yaml
   spring:
     cloud:
       sentinel:
         datasource:
           ds1:
             nacos:
               server-addr: localhost:8848
               dataId: ${spring.application.name}
               groupId: DEFAULT_GROUP
               data-type: json
               rule-type: flow # com.alibaba.cloud.sentinel.datasource.RuleType
   ```

3. nacos中新增对应配置即可



### 题外话..

当前版本sentinel不支持自动同步到nacos的话

可能需要自己修改sentinel源码



# 结 の 奥义

## OpenFeign & Sentinel

--> fallback服务降级

### 准备工作

1. nacos正常启动

2. sentinel正常启动

3. 任何一方都需要引入通用api包

4. 服务提供方：

   I.需引入openfeign & sentinel & nacos-discovery

   II.需配置yml文件，注册到nacos中，并配置sentinel地址

   III.启动类加上所需注解 （discovery的..）

5. 通用api包：

   I.需引入openfeign & sentinel

   II.服务提供方的接口写入到通用api中，并为远程调用新建统一服务降级

   统一服务降级类实现通用api类，重写其中的所有接口，降级直接走对应重写的内容

   ```java
   @FeignClient(value = "提供者注册名称",fallback = 统一降级处理类.class)
   public interface PayFeignSentinelApi{
       @GetMapping("/pay/nacos/get/{orderNo}")
       public ResultData getPayByOrderNo(@PathVariable("orderNo") String orderNo);
   }
   ```

   ```java
   @Component
   public class PayFeignSentinelApiFallBack implements PayFeignSentinelApi{
       @Override
       public ResultData getPayByOrderNo(String orderNo){
           return ResultData.fail(ReturnCodeEnum.RC500.getCode(),"对方服务宕机或不可用，FallBack服务降级o(╥﹏╥)o");
       }
   }
   ```

6. 服务消费者：

   I.引入openfeign & sentinel & nacos-discovery

   II. **重中之重：** 激活Sentinel对Feign的支持

   ```yaml
   # 激活Sentinel对Feign的支持
   feign:
     sentinel:
       enabled: true
   ```

   III.启动类上启用Feign功能`@EnableFeignClients`



启动服务消费者报错：

```bash
Caused by: java.lang.IllegalStateException: Method PayFeignSentinelApi#getPayByOrderNo(String) not annotated with HTTP method type (ex. GET, POST)
...
```

原因：springboot + springcloud 版本过高，sentinel不兼容

解决方案：降低版本





## GateWay & Sentinel

--> 服务限流 

 











































