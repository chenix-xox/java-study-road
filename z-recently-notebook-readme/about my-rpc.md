## RPC设计

>   **最简单的RPC：**
>
> - 服务提供端 Server 向注册中心注册服务
> - 服务消费者 Client 通过注册中心拿到服务相关信息
> - 然后再通过网络请求服务提供端 Server

### 所需

- **注册中心：**负责服务地址的注册与查找

  可使用的：Zookeeper、Nacos 或 Redis.. 甚至可以使用文件！

- **网络传输：**调用远程方法，就需要发送网络请求传递<u>目标的信息</u>到**服务提供端**

  > **可使用的：**
  >
  > Socket：Java中最原始最基础的网络通信方式，**阻塞IO**，性能低且功能单一
  >
  > NIO：同步非阻塞的IO模型，但麻烦
  >
  > **（推荐）**Netty：基于NIO的client-server（客户端服务器）框架	

- **序列化和反序列化：**网络传输数据必须是二进制的，因此需要将Java对象进行**序列化**；接收到二进制数据后，解析（**反序列化**）为Java对象

  > **可使用的：**
  >
  > （不推荐）实现`java.io.Serializable`接口（JDK自带）：不支持跨语言调用且性能较差
  >
  > 常用序列化方式：hessian、kryo、protostuff

- **动态代理：** 我们给某一个对象提供一个代理对象，并由代理对象来代替真实对象做一些事情

  > **举个例子：**我们真实对象调用方法的时候，我们可以通过代理对象去做一些事情比如安全校验、日志打印等等。但是，这个过程是完全对真实对象屏蔽的。

  RPC的主要目的就是调用远程方法西像本地方法一样简单，不关心方法调用的细节，如网络传输..

  就可以用到动态代理，让代理对象来传输网络请求

- **负载均衡：**避免单个服务器响应同一个请求，造成服务器宕机、崩溃等问题

- **传输协议：**设计一个私有的传输协议，作为客户端和服务端交流的基础

