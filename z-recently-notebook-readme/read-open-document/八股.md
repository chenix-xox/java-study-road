## 特别鸣谢 - 参考文档

[Java 面试指南 | JavaGuide](https://javaguide.cn/)

[Javaᶜⁿ 面试突击 (javacn.site)](https://javacn.site/)

## Hashtable和HashMap的区别

hashtable是线程安全的，但也正因为他使用了同步锁，因此性能上是不如hashmap的。然后hashtable不允许存在为null的key和value，hashmap可以存在。因为在hashtable中，key需要进行哈希计算的，value会直接报空指针异常。hashmap中如果key为null，会直接赋值为0。

官方是不太推荐使用hashtable的，因为性能太低了，多线程环境可以使用ConcurrentHashMap，保证线程安全的同时性能也不会太差。



## hashset和hashmap的区别？

实现接口的不同，一个实现了set，一个实现了map。hashset一般用于存储不重复的对象，hashmap存储的是键值对，键不可重复。hashset的底层用的还是hashmap，只不过他是自己封装了一系列方法，讲自己的值存到hashmap。因为hashmap存储的是键值对，因此他是可以通过键实现查找功能的



## 负载因子loadfactor及0.75？

负载因子指的是hashmap容量不足，需要扩容的一个阈值。当 hashmap的存储容量 达到:

初始化空间initcapacity*0.75的时候，就会进行扩容。避免hash冲突，提高性能

负载因子过大，空间利用率增加了，但是时间效率降低了。

而当负载因子过小，确实查询速度会变快，，时间效率提高了，但空间利用率小，增加了存储负担

0.75是官方推荐的一个值，根据官方所说，0.75提供了时间和空间复杂度之间的良好平衡。经过许多科学数学公式验证所得



## hashmap的底层实现

HashMap 在 JDK 1.7 时，是通过数组 + 链表实现的，而在 JDK 1.8 时，HashMap 是通过数组 + 链表或红黑树实现的。在 JDK 1.8 之后，如果链表的数量大于阈值（默认为 8），并且数组长度大于 64 时，为了查询效率会将链表升级为红黑树，但当红黑树的节点小于等于 6 时，为了节省内存空间会将红黑树退化为链表。



## = = 和 equals的区别



