# 3V和3高

大数据时代的3V

- 海量Volume
- 多样Variety
- 实时Velocity



互联网需求的3高

- 高并发
- 高可拓
- 高性能





# 杂谈

[阿里云的这群疯子](https://www.huxiu.com/article/267100.html)



> - 商品基本信息
>
>   名称、价格、商家信息...
>
>   MySQL
>
> - 商品的描述、评论（文字较多）
>
>   文档型数据库，MongoDB
>
> - 图片
>
>   分布式文件系统 FastDFS
>
>   阿里云：OSS
>
>   Hadoop：HDFS
>
> - 商品关键字（搜索）
>
>   搜索引擎：solr / elasticsearch
>
>   Isearch：阿里-多隆
>
> - 商品热门的波段信息
>
>   内存数据库：Redis、Tair、Memache...
>
> - 商品交易、外部的支付接口
>
>   第三方应用



**MongoDB：**

介于关系型数据库和非关系系数据库之间，是非关系型数据库中功能最丰富，最像关系型数据库的





# 概述

**能干什么**

1. 内存存储、持久化，内存中是断电即失、所以说持久化很重要(rdb、aof)
2. 效率高，可以用于高速缓存
3. 发布订阅系统
4. 地图信息分析
5. 计时器、计数器（浏览量！）



**特性**

1. 多样的数据类型
2. 持久化
3. 集群
4. 事务
5. ...



# 安装

1. 下载redis-7.2.4.tar.gz	

2. 放到opt目录下

   ```bash
   mv redis-7.2.4.tar.gz /opt
   ```

3. 在opt目录下解压

   ```bash
   cd /tar
   tar -zxvf redis-7.2.4.tar.gz
   ```

4. 基本环境：安装gcc，执行make，执行make instal

5. 默认安装路径：`cd /usr/local/bin/`

6. 将redis配置文件复制到当前目录（redis安装目录）

7. 使用配置文件进行启动

   **Redis默认不是后台启动的，修改配置文件！**

   修改`daemonize no`为**yes**

8. 通过配置文件启动redis

   在redis的安装目录中 `redis-server cconfig/redis.conf `

   > **报错**
   >
   > WARNING Memory overcommit must be enabled! Without it, a background save or replication may fail under low memory condition. Being disabled, it can also cause failures without low memory condition, see https://github.com/jemalloc/jemalloc/issues/1328. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.

   > **解决方案**
   >
   > 在/etc/sysctl.conf中加入sysctl vm.overcommit_memory=1
   >
   > 然后重启机器or刷新
   >
   > 刷新：
   >
   > /sbin/sysctl -p 
   >
   > /sbin/sysctl -w net.ipv4.route.flush=1

9. 启动redis客户端进行连接 `redis-cli -p 6379`

10. 复制服务器会话，查看已开启的redis服务 `ps -ef | grep redis`



# Redis命令



1. ping : 测试Redis是否连接成功，连接成功返回PONG

2. set [参数名] [参数值] ： 创建键值对

3. get [参数名] ： 根据键查看值

4. keys * : 查看所有已存在的值

5. shutdown ： 关闭redis服务

6. exit ： 退出

7. select [序号] ： 切换到指定数据库

8. DBSIZE ： 查看数据库大小

9. flushdb ： 清空当前数据库的所有键值对

10. flushall ： 清空全部数据库的键值对

11. exists [参数名] : 查询某个参数是否存在（返回 1/0 ）

12. move [参数名] [数据库序号] : 移动参数到指定数据库（好像如果是当前数据库的话，就会产生移除效果）

13. expire [参数名] [多少秒] : 设置某个参数多少秒过期

14. ttl [参数名] ： 查看参数剩余过期时间

15. del [参数名] ： 删除参数

16. type [参数名] ： 查看参数数据类型

17. **###########   Sring👇   #############**

18. append [参数名] [参数值] ： 在指定参数后面加上对应参数值（如果该参数不存在，此命令等于set key）

19. strlen [参数名] ： 获取字符串长度

20. getrange [参数名] [起始位置] [结束位置] ： 获取参数起始位置到结束位置的值（ **ps：**获取从头到尾，可以设置0,-1）

21. setrange [参数名] [起始位置] [替换值] : 将指定参数，从指定起始位置，开始替换，替换为 指定替换值

22. **################   做 ++ 操作（浏览量，点击量...） 👇 ##################**

23. > set views 0; // 创建浏览量参数
    >
    > incr views; // 开始++
    >
    > decr views; // 开始--
    >
    > incrby views [步长]; // 根据步长开始++，例如步长为10，直接+10
    >
    > decrby views [步长]; // 根据步长开始--，例如步长为10，直接-10

24.  **######################   ..其他.. 👇  ###########################**

25. setex [参数名] [过期时间] [参数值] ： 带着参数时间建立参数

26. **setnx [参数名] [参数值]** ： **<u>（在分布式锁中会常常使用！）</u>**如果参数名不存在，则创建对应参数，如果存在，则不继续进行创建

27. mset [参数名1] [参数值1] [参数名2] [参数值2] ... ： 批量创建参数

28. mget [参数名1] [参数名2] [参数名3] ... ： 批量获取参数

29. msetnx [参数名1] [参数值1] [参数名2] [参数值2] ... ： 批量创建参数(如果参数名不存在，则创建...)

30. > **使用mset创建json数据**
    >
    > mset user:1:name zhangsan user:1:age 2
    >
    > mget user:1:name user:1:age
    >
    > **格式：**user:{id}:{filed}
    >
    > 例如：设置第1000篇文章的浏览量
    >
    > set article:1000:views 0;

31. getset [参数名] [参数值] ： 先获取，再创建

    > 例如，创建一个不存在的参数，使用 getset db redis;
    >
    > 会返回一个 (nil) 不存在，但是已经创建好了db参数
    >
    > 此时，再次使用 getset db mongodb
    >
    > 将返回 redis，并覆盖为mongodb

32. **################   List 👇   ##################**

33. 



# 测试性能

`redis-benchmark`：压力测试工具

官方自带的性能测试工具

| 序号 | 选项               | 描述                                       | 默认值    |
| ---- | ------------------ | ------------------------------------------ | --------- |
| 1    | -h                 | 指定服务器主机名                           | 127.0.0.1 |
| 2    | -p                 | 指定服务器端口                             | 6379      |
| 3    | -s                 | 指定服务器 socket                          |           |
| 4    | -c                 | 指定并发连接数                             | 50        |
| 5    | -n                 | 指定请求数                                 | 10000     |
| 6    | -d                 | 以字节的形式指定 SET/GET 值的数据大小      | 2         |
| 7    | -k                 | 1=keep alive 0=reconnect                   | 1         |
| 8    | -r                 | SET/GET/INCR 使用随机 key, SADD 使用随机值 |           |
| 9    | -P                 | 通过管道传输 <numreq> 请求                 | 1         |
| 10   | -q                 | 强制退出 redis。仅显示 query/sec 值        |           |
| 11   | --csv              | 以 CSV 格式输出                            |           |
| 12   | -l（L 的小写字母） | 生成循环，永久执行测试                     |           |
| 13   | -t                 | 仅运行以逗号分隔的测试命令列表。           |           |
| 14   | -I（i 的大写字母） | Idle 模式。仅打开 N 个 idle 连接并等待。   |           |

**例如：**测试 100个并发连接 ， 100000个请求

`redis-benchmark -h localhost -p 6379 -c 100 -n 100000`

测试结果字段解释 —— SET部分：

> ====== SET ======                          
>
>  100000 requests completed in 0.82 seconds
>
>  100 parallel clients	：	**100个并发客户端**
>
>  3 bytes payload	：	**每次写入3个字节**
>
>  keep alive: 1	：	**只有一台服务器来处理这些请求，单机性能**
>
>  host configuration "save": 3600 1 300 100 60 10000
>
>  host configuration "appendonly": no
>
>  multi-thread: no
>
> throughput summary: 140845.08 requests per second	：	**每秒处理140845.08个请求**
>



# 基础知识

默认16个数据库，在redis.conf中

`databases 16`

默认使用第0个，可以是用select进行切换数据库（见Redis命令第6个）









# 五大数据类型

> - Redis-Key
> - String
> - List
> - Set（集合）
> - Hash（散列）
> - Zset

## String

**常用如下**

1. append [参数名] [参数值] ： 在指定参数后面加上对应参数值（如果该参数不存在，此命令等于set key）

2. strlen [参数名] ： 获取字符串长度

3. getrange [参数名] [起始位置] [结束位置] ： 获取参数起始位置到结束位置的值（ **ps：**获取从头到尾，可以设置0,-1）

4. setrange [参数名] [起始位置] [替换值] : 将指定参数，从指定起始位置，开始替换，替换为 指定替换值

5. > set views 0; // 创建浏览量参数
   >
   > incr views; // 开始++
   >
   > decr views; // 开始--
   >
   > incrby views [步长]; // 根据步长开始++，例如步长为10，直接+10
   >
   > decrby views [步长]; // 根据步长开始--，例如步长为10，直接-10

6. setex [参数名] [过期时间] [参数值] ： 带着参数时间建立参数

7. **setnx [参数名] [参数值]** ： **<u>（在分布式锁中会常常使用！）</u>**如果参数名不存在，则创建对应参数，如果存在，则不继续进行创建

8. mset [参数名1] [参数值1] [参数名2] [参数值2] ... ： 批量创建参数

9. mget [参数名1] [参数名2] [参数名3] ... ： 批量获取参数

10. msetnx [参数名1] [参数值1] [参数名2] [参数值2] ... ： 批量创建参数(如果参数名不存在，则创建...)

11. > **使用mset创建json数据**
    >
    > mset user:1:name zhangsan user:1:age 2
    >
    > mget user:1:name user:1:age
    >
    > **格式：**user:{id}:{filed}
    >
    > 例如：设置第1000篇文章的浏览量
    >
    > set article:1000:views 0;

12. getset [参数名] [参数值] ： 先获取，再创建

    > 例如，创建一个不存在的参数，使用 getset db redis;
    >
    > 会返回一个 (nil) 不存在，但是已经创建好了db参数
    >
    > 此时，再次使用 getset db mongodb
    >
    > 将返回 redis，并覆盖为mongodb



## List

list可以玩成 栈、队列、阻塞队列！

栈：先进后出

队列：先进先出

阻塞队列：两边都开？

**所有的list命令都是以l开头**

1. LPUSH/RPUSH [参数名] [参数值] : 可以不断往同一个参数名中放入值（L代表的是从左边开始放值，R是从右边开始放值）
2. LRANGE [参数名] [起始位置] [结束位置] ： 查询list，如果查询全部，直接 `LRANGE xxx 0 -1`
3. LPOP/RPOP [参数名] ： 移除一个值（ L / R 左或右 ）
4. LINDEX [参数名] [下标] ： 通过下标获取值
5. LLEN [参数名] ： 返回列表的长度
6. LREM [参数名] [COUNT] [参数值] ： 移除指定参数中的指定值，移除COUNT个
7. LTRIM [参数名] [起始位置] [结束位置] ： 只留下指定位置到指定位置的内容
8. RPOPLPUSH [参数1] [参数2] ： 移除参数1的最后一个值，并插入到参数2（被移除的值插入到参数2） 



# 三种特殊数据类型



> - geospatial
> - hyperloglog
> - bitmaps







































