# 始于 2024.3.15



# 3V和3高

大数据时代的3V

- 海量Volume
- 多样Variety
- 实时Velocity



互联网需求的3高

- 高并发
- 高可拓
- 高性能





# 杂谈

[阿里云的这群疯子](https://www.huxiu.com/article/267100.html)



> - 商品基本信息
>
>   名称、价格、商家信息...
>
>   MySQL
>
> - 商品的描述、评论（文字较多）
>
>   文档型数据库，MongoDB
>
> - 图片
>
>   分布式文件系统 FastDFS
>
>   阿里云：OSS
>
>   Hadoop：HDFS
>
> - 商品关键字（搜索）
>
>   搜索引擎：solr / elasticsearch
>
>   Isearch：阿里-多隆
>
> - 商品热门的波段信息
>
>   内存数据库：Redis、Tair、Memache...
>
> - 商品交易、外部的支付接口
>
>   第三方应用



**MongoDB：**

介于关系型数据库和非关系系数据库之间，是非关系型数据库中功能最丰富，最像关系型数据库的





# 概述

**能干什么**

1. 内存存储、持久化，内存中是断电即失、所以说持久化很重要(rdb、aof)
2. 效率高，可以用于高速缓存
3. 发布订阅系统
4. 地图信息分析
5. 计时器、计数器（浏览量！）



**特性**

1. 多样的数据类型
2. 持久化
3. 集群
4. 事务
5. ...



# 安装

1. 下载redis-7.2.4.tar.gz	

2. 放到opt目录下

   ```bash
   mv redis-7.2.4.tar.gz /opt
   ```

3. 在opt目录下解压

   ```bash
   cd /tar
   tar -zxvf redis-7.2.4.tar.gz
   ```

4. 基本环境：安装gcc，执行make，执行make instal

5. 默认安装路径：`cd /usr/local/bin/`

6. 将redis配置文件复制到当前目录（redis安装目录）

7. 使用配置文件进行启动

   **Redis默认不是后台启动的，修改配置文件！**

   修改`daemonize no`为**yes**

8. 通过配置文件启动redis

   在redis的安装目录中 `redis-server cconfig/redis.conf `

   > **报错**
   >
   > WARNING Memory overcommit must be enabled! Without it, a background save or replication may fail under low memory condition. Being disabled, it can also cause failures without low memory condition, see https://github.com/jemalloc/jemalloc/issues/1328. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.

   > **解决方案**
   >
   > 在/etc/sysctl.conf中加入sysctl vm.overcommit_memory=1
   >
   > 然后重启机器or刷新
   >
   > 刷新：
   >
   > /sbin/sysctl -p 
   >
   > /sbin/sysctl -w net.ipv4.route.flush=1

9. 启动redis客户端进行连接 `redis-cli -p 6379`

10. 复制服务器会话，查看已开启的redis服务 `ps -ef | grep redis`



# Redis命令



1. ping : 测试Redis是否连接成功，连接成功返回PONG

2. set [参数名] [参数值] ： 创建键值对

3. get [参数名] ： 根据键查看值

4. keys * : 查看所有已存在的值

5. shutdown ： 关闭redis服务

6. exit ： 退出

7. select [序号] ： 切换到指定数据库

8. DBSIZE ： 查看数据库大小

9. flushdb ： 清空当前数据库的所有键值对

10. flushall ： 清空全部数据库的键值对

11. exists [参数名] : 查询某个参数是否存在（返回 1/0 ）

12. move [参数名] [数据库序号] : 移动参数到指定数据库（好像如果是当前数据库的话，就会产生移除效果）

13. expire [参数名] [多少秒] : 设置某个参数多少秒过期

14. ttl [参数名] ： 查看参数剩余过期时间

15. del [参数名] ： 删除参数

16. type [参数名] ： 查看参数数据类型

17. **###########   Sring👇   #############**

18. append [参数名] [参数值] ： 在指定参数后面加上对应参数值（如果该参数不存在，此命令等于set key）

19. strlen [参数名] ： 获取字符串长度

20. getrange [参数名] [起始位置] [结束位置] ： 获取参数起始位置到结束位置的值（ **ps：**获取从头到尾，可以设置0,-1）

21. setrange [参数名] [起始位置] [替换值] : 将指定参数，从指定起始位置，开始替换，替换为 指定替换值

22. **################   做 ++ 操作（浏览量，点击量...） 👇 ##################**

23. > set views 0; // 创建浏览量参数
    >
    > incr views; // 开始++
    >
    > decr views; // 开始--
    >
    > incrby views [步长]; // 根据步长开始++，例如步长为10，直接+10
    >
    > decrby views [步长]; // 根据步长开始--，例如步长为10，直接-10

24.  **######################   ..其他.. 👇  ###########################**

25. setex [参数名] [过期时间] [参数值] ： 带着参数时间建立参数

26. **setnx [参数名] [参数值]** ： **<u>（在分布式锁中会常常使用！）</u>**如果参数名不存在，则创建对应参数，如果存在，则不继续进行创建

27. mset [参数名1] [参数值1] [参数名2] [参数值2] ... ： 批量创建参数

28. mget [参数名1] [参数名2] [参数名3] ... ： 批量获取参数

29. msetnx [参数名1] [参数值1] [参数名2] [参数值2] ... ： 批量创建参数(如果参数名不存在，则创建...)

30. > **使用mset创建json数据**
    >
    > mset user:1:name zhangsan user:1:age 2
    >
    > mget user:1:name user:1:age
    >
    > **格式：**user:{id}:{filed}
    >
    > 例如：设置第1000篇文章的浏览量
    >
    > set article:1000:views 0;

31. getset [参数名] [参数值] ： 先获取，再创建

    > 例如，创建一个不存在的参数，使用 getset db redis;
    >
    > 会返回一个 (nil) 不存在，但是已经创建好了db参数
    >
    > 此时，再次使用 getset db mongodb
    >
    > 将返回 redis，并覆盖为mongodb

32. **################   List 👇   ##################**

33. LPUSH/RPUSH [参数名] [参数值] : 可以不断往同一个参数名中放入值（L代表的是从左边开始放值，R是从右边开始放值）

34. LRANGE [参数名] [起始位置] [结束位置] ： 查询list，如果查询全部，直接 `LRANGE xxx 0 -1`

35. LPOP/RPOP [参数名] ： 移除一个值（ L / R 左或右 ）

36. LINDEX [参数名] [下标] ： 通过下标获取值

37. LLEN [参数名] ： 返回列表的长度

38. LREM [参数名] [COUNT] [参数值] ： 移除指定参数中的指定值，移除COUNT个

39. LTRIM [参数名] [起始位置] [结束位置] ： 只留下指定位置到指定位置的内容

40. RPOPLPUSH [参数1] [参数2] ： 移除参数1的最后一个值，并插入到参数2（被移除的值插入到参数2） 

41. LSET [参数名] [下标] [参数值] ： 将指定参数的，指定下标的内容替换为新的参数值

42. LINSERT [参数名] [位置（before/after）] [哪个值] [参数值] ： 在指定**参数名**的**before/after**的位置，**指定某个值**添加**参数值**

43. **################   Hash   👇 ################**

44. HSET [参数名] [key] [value] ： 创建参数，值为 <u>Map键值对</u>

45. HGET [参数名] [key] ： 指定参数名，获取指定key的value

46. HMSET [参数名] [key1] [value1] [key2] [value2] [key3] [value3] : 批量创建Map键值对

47. HMGET [参数名] [key1] [key2] ： 批量获取指定key的value

    > Redis4.0开始，弃用HMSET，直接使用HSET也可以批量创建

48. HGETALL [参数名] ： 获取一个指定参数中的**所有键值对**

    > **顺着以**
    >
    > key1
    >
    > value1
    >
    > key2
    >
    > value2
    >
    > **显示**

49. HDEL [参数名] [key1] [key2] ： 删除指定参数的指定key

50. HLEN [参数名] : 查看key-value个数

51. HEXISTS [参数名] [key] ： 判断指定参数名中的指定key是否存在

52. HKEYS [参数名] ： 获取指定参数名中的**所有key**

53. HVALS [参数名] ： 获取指定参数名中的**所有value**

54. HINCRBY [参数名] [key] [数值] ： 给指定参数名的 指定key 的value 增加或减少 一个值

55. HSETNX [参数名] [key] [value] ： 不存在则添加成功，存在则添加失败

56. **#######################   Zser  👇 #########################**

57. zadd [参数名] [序号位置] [参数值] ： 给指定参数添加指定参数值，并配上其序号位置，作为排序依据【这个排序依据，称为Score】

58. zrange [参数名] [起始位置] [结束位置] ： 查看有序集合

    **PS：**还有ZREVRANGE

59. zrangebyscore [参数名] [min] [max] ： 将指定参数名，通过SCORE，进行范围查看，从指定的min值，到指定的max值查看

    **PS**：使用ZREVRANGEBYSCORE，可以从max到min进行查看【逆序】  

    > **例如**
    >
    > ZRANGEBYSCORE xxx -inf +inf	：表示从负无穷到正无穷排序，就是从小到大排序
    >
    > ZRANGEBYSCORE xxx -inf 2500	：表示从负无穷到最大2500排序

60. zrangebyscore [参数名] [min] [max] WITHSCORES ： 如上，会带上SCORE内容

    > **查询结果，如下：**
    >
    > "value1"
    >
    > "score1"
    >
    > "value2"
    >
    > "score2"
    >
    > ...

61. ZCARD [参数名] ： 查看指定参数名的元素个数 

62. ZCOUNT [参数名] [起始位置] [结束位置] ： 获取起始位置到结束位置中间值的个数 













# 测试性能

`redis-benchmark`：压力测试工具

官方自带的性能测试工具

| 序号 | 选项               | 描述                                       | 默认值    |
| ---- | ------------------ | ------------------------------------------ | --------- |
| 1    | -h                 | 指定服务器主机名                           | 127.0.0.1 |
| 2    | -p                 | 指定服务器端口                             | 6379      |
| 3    | -s                 | 指定服务器 socket                          |           |
| 4    | -c                 | 指定并发连接数                             | 50        |
| 5    | -n                 | 指定请求数                                 | 10000     |
| 6    | -d                 | 以字节的形式指定 SET/GET 值的数据大小      | 2         |
| 7    | -k                 | 1=keep alive 0=reconnect                   | 1         |
| 8    | -r                 | SET/GET/INCR 使用随机 key, SADD 使用随机值 |           |
| 9    | -P                 | 通过管道传输 <numreq> 请求                 | 1         |
| 10   | -q                 | 强制退出 redis。仅显示 query/sec 值        |           |
| 11   | --csv              | 以 CSV 格式输出                            |           |
| 12   | -l（L 的小写字母） | 生成循环，永久执行测试                     |           |
| 13   | -t                 | 仅运行以逗号分隔的测试命令列表。           |           |
| 14   | -I（i 的大写字母） | Idle 模式。仅打开 N 个 idle 连接并等待。   |           |

**例如：**测试 100个并发连接 ， 100000个请求

`redis-benchmark -h localhost -p 6379 -c 100 -n 100000`

测试结果字段解释 —— SET部分：

> ====== SET ======                          
>
>  100000 requests completed in 0.82 seconds
>
>  100 parallel clients	：	**100个并发客户端**
>
>  3 bytes payload	：	**每次写入3个字节**
>
>  keep alive: 1	：	**只有一台服务器来处理这些请求，单机性能**
>
>  host configuration "save": 3600 1 300 100 60 10000
>
>  host configuration "appendonly": no
>
>  multi-thread: no
>
> throughput summary: 140845.08 requests per second	：	**每秒处理140845.08个请求**
>



# 基础知识

默认16个数据库，在redis.conf中

`databases 16`

默认使用第0个，可以是用select进行切换数据库（见Redis命令第6个）









# 五大数据类型

> - Redis-Key
> - String
> - List
> - Set（集合）
> - Hash（散列）
> - Zset

## String

**常用如下**

1. append [参数名] [参数值] ： 在指定参数后面加上对应参数值（如果该参数不存在，此命令等于set key）

2. strlen [参数名] ： 获取字符串长度

3. getrange [参数名] [起始位置] [结束位置] ： 获取参数起始位置到结束位置的值（ **ps：**获取从头到尾，可以设置0,-1）

4. setrange [参数名] [起始位置] [替换值] : 将指定参数，从指定起始位置，开始替换，替换为 指定替换值

5. > set views 0; // 创建浏览量参数
   >
   > incr views; // 开始++
   >
   > decr views; // 开始--
   >
   > incrby views [步长]; // 根据步长开始++，例如步长为10，直接+10
   >
   > decrby views [步长]; // 根据步长开始--，例如步长为10，直接-10

6. setex [参数名] [过期时间] [参数值] ： 带着参数时间建立参数

7. **setnx [参数名] [参数值]** ： **<u>（在分布式锁中会常常使用！）</u>**如果参数名不存在，则创建对应参数，如果存在，则不继续进行创建

8. mset [参数名1] [参数值1] [参数名2] [参数值2] ... ： 批量创建参数

9. mget [参数名1] [参数名2] [参数名3] ... ： 批量获取参数

10. msetnx [参数名1] [参数值1] [参数名2] [参数值2] ... ： 批量创建参数(如果参数名不存在，则创建...)

11. > **使用mset创建json数据**
    >
    > mset user:1:name zhangsan user:1:age 2
    >
    > mget user:1:name user:1:age
    >
    > **格式：**user:{id}:{filed}
    >
    > 例如：设置第1000篇文章的浏览量
    >
    > set article:1000:views 0;

12. getset [参数名] [参数值] ： 先获取，再创建

    > 例如，创建一个不存在的参数，使用 getset db redis;
    >
    > 会返回一个 (nil) 不存在，但是已经创建好了db参数
    >
    > 此时，再次使用 getset db mongodb
    >
    > 将返回 redis，并覆盖为mongodb







## List

list可以玩成 栈、队列、阻塞队列！

栈：先进后出

队列：先进先出

阻塞队列：两边都开？

**所有的list命令都是以l开头**

1. LPUSH/RPUSH [参数名] [参数值] : 可以不断往同一个参数名中放入值（L代表的是从左边开始放值，R是从右边开始放值）
2. LRANGE [参数名] [起始位置] [结束位置] ： 查询list，如果查询全部，直接 `LRANGE xxx 0 -1`
3. LPOP/RPOP [参数名] ： 移除一个值（ L / R 左或右 ）
4. LINDEX [参数名] [下标] ： 通过下标获取值
5. LLEN [参数名] ： 返回列表的长度
6. LREM [参数名] [COUNT] [参数值] ： 移除指定参数中的指定值，移除COUNT个
7. LTRIM [参数名] [起始位置] [结束位置] ： 只留下指定位置到指定位置的内容
8. RPOPLPUSH [参数1] [参数2] ： 移除参数1的最后一个值，并插入到参数2（被移除的值插入到参数2） 
9. LSET [参数名] [下标] [参数值] ： 将指定参数的，指定下标的内容替换为新的参数值
10. LINSERT [参数名] [位置（before/after）] [哪个值] [参数值] ： 在指定**参数名**的**before/after**的位置，**指定某个值**添加**参数值**







## Set（集合）

set中的值不能重复！

1. SADD [参数名] [参数值] : 添加集合元素
2. SMEMBERS [参数名] : 查看集合元素
3. SISMEMBER [参数名] [参数值] ： 查看指定参数名，是否存在指定参数，返回 1 / 0
4. SCARD [参数名] ： 查看集合中的元素个数
5. SREM [参数名] [参数值] ： 移除指定参数名中的指定参数值
6. SRANDMEMBER [参数名] [个数]： 从指定参数名中取出随机参数值，可以不写数量值，默认一个
7. SPOP [参数名] ： 从指定参数名的集合中随机取出元素
8. SMOVE [参数名1] [参数名2] [参数值] ： 将指定参数名1内的指定参数值，移动到参数名2
9. SDIFF [参数名1] [参数名2] ： 查看参数名1中，参数名2没有的元素（差集）
10. SINTER [参数名1] [参数名2] ： 查看参数名1和参数名2中的共同元素（交集）（共同好友）
11. SUNION [参数名1] [参数名2] ： 查看参数名1和参数名2加起来的所有元素【去重】（并集）





## Hash（哈希）

1. HSET [参数名] [key] [value] ： 创建参数，值为 <u>Map键值对</u>

2. HGET [参数名] [key] ： 指定参数名，获取指定key的value

3. HMSET [参数名] [key1] [value1] [key2] [value2] [key3] [value3] : 批量创建Map键值对

4. HMGET [参数名] [key1] [key2] ： 批量获取指定key的value

   > Redis4.0开始，弃用HMSET，直接使用HSET也可以批量创建

5. HGETALL [参数名] ： 获取一个指定参数中的**所有键值对**

   > **顺着以**
   >
   > key1
   >
   > value1
   >
   > key2
   >
   > value2
   >
   > **显示**

6. HDEL [参数名] [key1] [key2] ： 删除指定参数的指定key

7. HLEN [参数名] : 查看key-value个数

8. HEXISTS [参数名] [key] ： 判断指定参数名中的指定key是否存在

9. HKEYS [参数名] ： 获取指定参数名中的**所有key**

10. HVALS [参数名] ： 获取指定参数名中的**所有value**

11. HINCRBY [参数名] [key] [数值] ： 给指定参数名的 指定key 的value 增加或减少 一个值

12. HSETNX [参数名] [key] [value] ： 不存在则添加成功，存在则添加失败

 





## Zset（有序集合）

1. zadd [参数名] [序号位置] [参数值] ： 给指定参数添加指定参数值，并配上其序号位置，作为排序依据【这个排序依据，称为Score】

2. zrange [参数名] [起始位置] [结束位置] ： 查看有序集合

   **PS：**还有ZREVRANGE

3. zrangebyscore [参数名] [min] [max] ： 将指定参数名，通过SCORE，进行范围查看，从指定的min值，到指定的max值查看

   **PS**：使用ZREVRANGEBYSCORE，可以从max到min进行查看【逆序】  

   > **例如**
   >
   > ZRANGEBYSCORE xxx -inf +inf	：表示从负无穷到正无穷排序，就是从小到大排序
   >
   > ZRANGEBYSCORE xxx -inf 2500	：表示从负无穷到最大2500排序

4. zrangebyscore [参数名] [min] [max] WITHSCORES ： 如上，会带上SCORE内容

   > **查询结果，如下：**
   >
   > "value1"
   >
   > "score1"
   >
   > "value2"
   >
   > "score2"
   >
   > ...

5. ZCARD [参数名] ： 查看指定参数名的元素个数 

6. ZCOUNT [参数名] [起始位置] [结束位置] ： 获取起始位置到结束位置中间值的个数 







# 三种特殊数据类型



> - geospatial
> - hyperloglog
> - bitmaps

## geospatial地理位置

> Redis的Geo阿紫Redis3.2推出，可以推算地理位置信息，两地之间的距离，方圆几里的人

### GEOADD

添加地理位置

> **规则：**地球两极无法直接添加
>
> 一般会下载城市的数据，通过Java程序一次性导入

**格式：**`geoadd [参数1]:[参数2] [经度] [纬度] [城市名]`

> **例如：** geoadd china:city 121.47 31.23 shanghai
>
> **表示：** 添加 **中国:城市 / 经纬度 / 上海**

也可以一次性添加多个！

`geoadd china:city 121.47 31.23 shanghai 116.41 39.90 beijing`



### GEOPOS

查询地理位置

**格式：**`GEOPOS [参数1]:[参数2] [城市名]`

> **例如：**GEOPOS china:city beijing
>
> **表示：**查询**北京**的经纬度坐标

也可以一次性获取多个！

`GEOPOS china:city beijing wuhan`



### GEODIST

返回两个给定位置之间的距离

> **单位：**
>
> - m：米
> - km：千米
> - mi：英里
> - ft：英尺

**格式：**`GEODIST [参数1]:[参数2] [位置1] [位置2] [单位]`

> **例如：**GEODIST china:city beijing shanghai KM
>
> **表示：**计算北京和上海的直线距离，单位km



### GEORADIUS

以给定的经纬度为中心，找出某一半径的元素

**格式：**`GEORADIUS [参数1]:[参数2] [经度] [纬度] [距离] [单位]`

> **例子：**GEORADIUS china:city 116.41 39.9 10000 km
>
> **表示：**查询116.41 39.9 ，周围10000km以内的地点（从china:city）中

> **加在末尾的其他参数，返回附加信息：**
>
> - `WITHDIST`：也返回从指定中心点返回的项目的距离。距离以与命令的半径参数指定的单位相同的单位返回。
>
> - `WITHCOORD`: 也返回匹配项目的经度和纬度坐标。
>
> - `WITHHASH`：也返回项目的原始地理哈希编码排序集分数，以52位无符号整数的形式返回。这仅对低级别的黑客或调试有用，对普通用户来说没有太大兴趣。
>
>   
>
> **默认情况下，命令将返回未排序的项目。可以使用以下两个选项调用两种不同的排序方法：**
>
> - `ASC`：根据与中心点的距离，将返回的项目从最近到最远排序。
> - `DESC`：根据与中心点的距离，将返回的项目从最远到最近排序。
>
> 默认情况下，将返回所有匹配的项目。可以通过使用 **COUNT `<count>`** 选项将结果限制为前N个匹配的项目。 当提供了 `ANY` 时，命令会在找到足够的匹配项后立即返回， 因此结果可能不是离指定点最近的结果，但是服务器的投入量显著较低。 当未提供 `ANY` 时，命令将根据与指定区域匹配的项目数量进行排序并执行相应的操作， 因此，即使只返回了少量结果，在查询非常大的区域和非常小的 `COUNT` 选项时可能会很慢。



### GEORADIUSBYMEMBER

根据已有元素，查询其周围元素

格式：`GEORADIUSBYMEMBER [参数1]:[参数2] [城市名] [距离] [单位]`

> **例子：**GEORADIUSBYMEMBER china:city beijing 10000 km
>
> **表示：**查询北京周围10000km的元素





### GEOHASH

返回指定元素的Geohash字符串

**格式：**`GEOHASH [参数1]:[参数2] [城市名1] [城市名2]`

> **例子：**GEOHASH china:city beijing shanghai
>
> **表示：**返回北京和上海的geohash字符串，结果如下 👇
>
> 1) "wx4fbzx4me0"
> 2) "wtw3sj5zbj0"



### 注意

GEO底层实现原理就是Zset，因此可以使用Zset来操作Geo



## Hyperloglog

> 什么是基数？

A{1,3,5,7,8,7}

B{1,3,5,7,8}

基数，即一个集合中不重复的元素

上面的基数 = 5



### 简介

[HyperLogLog | Redis 中文网 (redisdocs.com)](https://www.redisdocs.com/zh-cn/docs/data-types/probabilistic/hyperloglogs/)

基数统计的算法，有0.81%的容错，允许容错的场景可以使用！

HyperLogLog是一种概率数据结构，用于估算一个集合的基数。



**应用场景：**网页UV（一个人访问一个网站多次，但是依旧算作一个人）

> **传统的方式：**set保存用户的id，set存储的是不重复元素，统计set中的元素数量作为判断标准
>
> **缺点：**保存大量用户id，很麻烦；目的是为了计数，而不是保存用户id；很占内存！

使用Hyperloglog，占内存是固定的，2^64个不同的元素的基数，仅12kb



### PFADD

将元素都添加到指定的一个参数中

**格式：**`PFADD [参数名] [参数值1] [参数值2] [参数值3] ...`

将参数值1~参数值3...，全部添加到这个参数名中



### PFCOUNT

统计指定参数的元素数量

**格式：**`PFCOUNT [参数名]`



### PFMERGE

将多个参数合并成一个新的参数

**格式：**`PFMERGE [新参数名] [旧参数名1] [旧参数名2] ...`





## Bitmaps

> 位存储

统计用户信息，活跃/不活跃；登录/不登陆；签到/不签到；

类似以上，只有两种状态的，都可以使用Bitmaps

Bitmaps位图，数据结构，都是使用二进制来进行记录，只有0和1两种状态



### SETBIT

创建位图

**格式：**setbit [参数] [key] [0/1]

> **key可以为任意数值，例如记录一年的打卡数据，就可以如下 👇：**
>
> - setbit sign 0 1
> - setbit sign 1 1
> - setbit sign 2 0





### GETBIT

获取位图

**格式：**getbit [参数] [key]

获取指定key的0/1





### BITCOUNT

统计位图中1的数量

**格式：**BITCOUNT [参数]

统计指定参数中，1的数量





# 事务



## Redis的事务

### 开启并执行事务

> - 开启事务（multi）
>
> - 命令入队
>
>   ```bash
>   set xxx xxx;
>   get xxx xxx;
>   set xxx xxx;
>   set xxx xxx;
>   ```
>
> - 执行事务（exec）



### 开启却取消事务

- 开启事务（multi）

- 命令入队

  ```bash
  set xxx xxx;
  get xxx xxx;
  set xxx xxx;
  set xxx xxx;
  ```

- 放弃事务（discard）



### 异常

- **【编译型异常】**开启事务，添加命令到事务队列的过程中，出现错误（如：语法错误），那么执行事务会报错，会执行失败
- **【运行时异常】**开启事务，添加命令到事务队列中，执行事务，中途出现错误的命令，会执行失败，不影响其他事务进行





## 监视事务 👇

> **监视器:**Watch

- **悲观锁：**很悲观，认为什么时候都会出问题，无论做什么都会加锁（影响性能）

- **乐观锁：**很乐观，认为什么时候都不会出问题，所以不会上锁

  更新数据的时候去判断一下，在此期间是否有人修改过这个数据

  > 获取version
  >
  > 更新的时候比较version



### 监视举例

```bash
set money 100
set out 0
watch money     # 监视 money 对象

multi            # 开启事务
DECRYBY money 20
INCRYBY out 20
exec			# 执行事务

#正常执行成功
```



### 模拟多线程实现乐观锁

> **客户端1：money减少20，花费增加20**
>
> ```bash
> watch money		# 开启监视 money
> multi            # 开启事务
> DECRYBY money 20
> INCRYBY out 20
> ```

**情况为：客户端1 👆 还没有执行线程， 客户端2 👇 把内容修改了！**

> **客户端2：改变money为1000**
>
> ```bash
> set money 1000;
> ```

此时，客户端1 执行事务，会执行失败（执行前，另一个客户端修改了被监视的内容），直接返回（nil）

此时就相当于使用Redis实现了乐观锁操作！



### After 乐观锁监视失败

> - 解锁，类似Mysql中放弃原来的version，获取新的version
>
>   **unwatch**
>
> 
>
> - 重新监视，拿到最新的值 
>
>   **watch money**





# Jedis

> **Jedis是Redis官方推荐的Java连接开发工具**

## 导包

```xml
<!-- https://mvnrepository.com/artifact/com.alibaba.fastjson2/fastjson2 -->
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2</artifactId>
    <version>2.0.47</version>
</dependency>

<!-- https://mvnrepository.com/artifact/redis.clients/jedis -->
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>5.1.0</version>
</dependency>
```



## 使用PING测试

```java
// 1. 新建Jedis对象
Jedis jedis = new Jedis("127.0.0.1",6379);
System.out.println(jedis.ping());

// 输出PONG，测试成功！
```



## Redis设置密码

**设置密码：**`config set requirepass [password]`

**查看密码：**`config get requirepass`



## Jedis连接键入密码

```java
jedis.auth("[password]");
```



## Jedis测试代码

```java
Jedis jedis = new Jedis("127.0.0.1", 6379);
jedis.auth("pwd");
System.out.println(jedis.ping());

System.out.println("清空数据：" + jedis.flushDB());
System.out.println("判断某个键是否存在：" + jedis.exists("username"));
System.out.println("新增<'username','xxx'>的键值对：" + jedis.set("username", "xxx"));
System.out.println("新增<'password','password'>的键值对：" + jedis.set("password", "pwd"));
System.out.print("系统中所有的键如下：");
Set<String> keys = jedis.keys("*");
System.out.println(keys);
System.out.println("password:" + jedis.del("password"));
System.out.println("判断键password,是否存在：" + jedis.exists("password"));
System.out.println("查看键username所存储的值的类型：" + jedis.type("username"));
System.out.println("随机返回key空间的一个：" + jedis.randomKey());
System.out.println("key:" + jedis.rename("username", "name"));
System.out.println("取出改后的name:" + jedis.get("name"));
System.out.println("按索引查询：" + jedis.select(0));
System.out.println("查看当前数据库中key的数目：" + jedis.dbSize());
System.out.println("查看当前数据库中所有的key：" + jedis.keys("*"));
System.out.println("删除当前选择数据库中的所有key:" + jedis.flushDB());
System.out.println("返回当前数据库中key的数目：" + jedis.dbSize());
System.out.println("删除所有数据库中的所有key:" + jedis.flushAll());

jedis.close();
```



## Jedis事务测试代码

> 事务执行失败，直接catch异常并关闭事务

```java
Jedis jedis = new Jedis("127.0.0.1", 6379);
jedis.auth("pwd");

// 添加测试数据
JSONObject jsonObject = new JSONObject();
jsonObject.put("username", "xxx");
jsonObject.put("password", "pwd");
String result = jsonObject.toString();

// 清空数据库
jedis.flushDB();

// 开启事务
Transaction multi = jedis.multi();
try {
    multi.set("user1", result);
    multi.set("user2", result);
    int i = 1 / 0;
    multi.exec();
} catch (Exception e) {
    // 执行失败，关闭事务
    multi.discard();
    e.printStackTrace();
} finally {
    // 执行成功，打印值
    System.out.println(jedis.get("user1"));
    System.out.println(jedis.get("user2"));

    // 关闭redis连接
    jedis.close();
}
```





# SpringBoot整合Redis

> **前言：**
>
> SpringBoot2.x之后，原来使用的jedis被替换为了lettuce
>
> **jedis：**采用的直连，多个线程操作是不安全的，想要避免不安全，需要使用jedis pool连接池（更像BIO模式）
>
> **lettuce：**底层采用netty，实例可以在多个线程中共享，不存在线程不安全的情况（更像NIO模式）

**Redis有一个模板技术**

在**spring-boot-autoconfigure**的包中

**spring.factories**中存在**RedisAutoConfiguration**

其绑定了**RedisProperties**，并且其中注入了**RedisTemplate模板**

其上标有注解**@ConditionalOnMissingBean(name = "redisTemplate")**

表示如果自己写了一个**redisTemplate类**，就可以替换掉这个模板

**默认的RedisTemplate**没有过多的设置，而**我们使用Redis**是需要序列化的



## 导包

```xml
<dependency>
    <groupId>io.lettuce</groupId>
    <artifactId>lettuce-core</artifactId>
    <version>6.3.1.RELEASE</version>
    <scope>compile</scope>
</dependency>
<dependency>
    <groupId>org.springframework.data</groupId>
    <artifactId>spring-data-redis</artifactId>
    <version>3.2.3</version>
    <scope>compile</scope>
</dependency>
```



## 添加配置文件

```yaml
spring:
  data:
    redis:
      host: 127.0.0.1
      port: 6379
      password: pwd
```

**注意：**如果需要配置连接池等内容，需要选择lettue进行配置，而不是jedis



## 测试

> **前言**
>
> OPS介绍：operation per second 每秒操作次数

**获取数据库连接对象，测试清空**

```java
RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();;
connection.flushAll();
connection.flushDb();
```



**常用方法可直接通过redisTemplate操作，比如事务和基本的crud**

> - **redisTempLate：操作不同的数据类型，api和我们的指令是一样的**
> - **opsForVaLue：操作字符串类似string**
> - **opsForList：操作List类似List**
> - **opsForSet**
> - **opsForHash**
> - **opsForZSet**
> - **opsForGeo**
> - **opsForHyperLogLog**



## 序列化铺垫

在Java程序中，没有序列化，进行键值对的创建，会导致服务器上查询出现乱码

```bash
127.0.0.1:6379> keys *
1) "\xac\xed\x00\x05t\x00\busername"
```





## 编写自己的Redis配置类

```java
@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory){
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    }
}
```





## 序列化测试

> 使用如下代码往redis中插入user对象会报错，因为该User对象没有进行序列化

```java
User user = new User("姓名", 18);
redisTemplate.opsForValue().set("user",user);
System.out.println(redisTemplate.opsForValue().get("user"));
```



> **解决方法其一：**将user转为json序列化字符串，传入redis

```java
User user = new User("姓名", 18);
String userJson = new ObjectMapper().writeValueAsString(user);
redisTemplate.opsForValue().set("user",userJson);
System.out.println(redisTemplate.opsForValue().get("user"));
```



> **解决方法其二：**所有对象进行序列化！

```java
public class User implements Serializable {
    private String name;
    private Integer age;
}
```



> **最优解决方案：**在Redis配置类中进行序列化相关配置 👇

## 自己定义RedisTemplate

> **@SuppressWarnings：**忽略所有警告（黄色下划线...）
>
> 在**SpringBoot3.x**中，写入了该Configuration后，使用**@Autowired注入的RedisTemplate**会使用我们自定义的这个来跑
>
> 在**SpringBoot2.x**中可能需要在**@Autowired下面加入一个@Qualifier("redisTemplate")**来指定调用我们自定义的
>
> 也可以尝试把**@Autowired注入的RedisTemplate**加入泛型，写为<String,Object>，与默认<Object,Object>不同，也可以指定到自定义的RedisTemplate

```java
/**
 * @author Chenix
 * @create 2024-03-22 19:02
 */
@Configuration
public class RedisConfig {
    @Bean
    @SuppressWarnings("all")
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        // 为了自己开发方便，一般直接使用<String, Object>类型
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);

        // 序列化配置
        // json的序列化
        Jackson2JsonRedisSerializer<Object> objectJackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        objectJackson2JsonRedisSerializer.setObjectMapper(om);

        // String的序列化
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        // key采用String的序列化方式
        template.setKeySerializer(stringRedisSerializer);
        // hash的key采用String的序列化方式
        template.setHashKeySerializer(stringRedisSerializer);
        // value采用jackson的序列化方式
        template.setValueSerializer(objectJackson2JsonRedisSerializer);
        // hash的value采用jackson的序列化方式
        template.setHashValueSerializer(objectJackson2JsonRedisSerializer);

        template.afterPropertiesSet();

        return template;
    }
}
```



## RedisUtils

> **前言：**
>
> 使用原生的Redis及OPS操作过于繁琐

编写一个RedisUtils，并使用**@Component**注入到容器

在需要用到的地方使用**@Autowired**注入调用

### 网上抄的一版

> [【RedisUtils工具类专题】SpringBoot中RedisUtils工具类配置及直接使用_springboot 的redisutils-CSDN博客](https://blog.csdn.net/qq_53641150/article/details/124180922)
>
> -utils
>
> ​	-RedisUtils02.java

**需要先引入fastjson**

```java
package com.xxx.utils;

import com.alibaba.fastjson.support.spring.GenericFastJsonRedisSerializer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.StringRedisSerializer;
import org.springframework.stereotype.Component;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

@Component
public class RedisUtils02 {
    private static RedisTemplate<String, Object> redisTemplate;
    public static RedisTemplate<String, Object> getRedisTemplate() {
        return redisTemplate;
    }
    @Autowired
    private RedisUtils02(RedisConnectionFactory redisConnectionFactory){
        // redisTemplate模板初始化
        redisTemplate = new RedisTemplate<>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        // String的序列化
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        // json序列化配置
        GenericFastJsonRedisSerializer jackson2JsonRedisSerializer = new GenericFastJsonRedisSerializer();
        //key采用String的序列化方式
        redisTemplate.setKeySerializer(stringRedisSerializer);
        //hash的key也采用String 的序列化方式
        redisTemplate.setHashKeySerializer(stringRedisSerializer);
        //value的序列化方式采用jackson的方式
        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);
        //hash的value序列化方式采用jackson
        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);
        redisTemplate.afterPropertiesSet();
    }

    // =============================common============================
    /**
     * 指定缓存失效时间
     * @param key  键
     * @param time 时间(秒)
     */
    public static boolean expire(String key, long time) {
        try {
            if (time > 0) {
                redisTemplate.expire(key, time, TimeUnit.SECONDS);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据key 获取过期时间
     * @param key 键 不能为null
     * @return 时间(秒) 返回0代表为永久有效
     */
    public static long getExpire(String key) {
        return redisTemplate.getExpire(key, TimeUnit.SECONDS);
    }


    /**
     * 判断key是否存在
     * @param key 键
     * @return true 存在 false不存在
     */
    public static boolean hasKey(String key) {
        try {
            return redisTemplate.hasKey(key);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 删除缓存
     * @param key 可以传一个值 或多个
     */
//    @SuppressWarnings("unchecked")
    public static void del(String... key) {
        if (key != null && key.length > 0) {
            if (key.length == 1) {
                redisTemplate.delete(key[0]);
            } else {
                redisTemplate.delete(Arrays.asList(key));
//                redisTemplate.delete(CollectionUtils.arrayToList(key));
            }
        }
    }

    /**
     * 获取并删除缓存
     * @param key 键
     * @return 值
     */
    public static Object getAndDelete(String key) {
        try{
            return key == null ? null : get(key);
        }finally {
            del(key);
        }
    }

    // ============================String=============================

    /**
     * 普通缓存获取
     * @param key 键
     * @return 值
     */
    public static Object get(String key) {
        return key == null ? null : redisTemplate.opsForValue().get(key);
    }

    /**
     * 普通缓存放入
     * @param key   键
     * @param value 值
     * @return true成功 false失败
     */

    public static boolean set(String key, Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 普通缓存放入并设置时间
     * @param key   键
     * @param value 值
     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期
     * @return true成功 false 失败
     */

    public static boolean set(String key, Object value, long time) {
        try {
            if (time > 0) {
                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 递增
     * @param key   键
     * @param delta 要增加几(大于0)
     */
    public static long incr(String key, long delta) {
        if (delta < 0) {
            throw new RuntimeException("递增因子必须大于0");
        }
        return redisTemplate.opsForValue().increment(key, delta);
    }


    /**
     * 递减
     * @param key   键
     * @param delta 要减少几(小于0)
     */
    public static long decr(String key, long delta) {
        if (delta < 0) {
            throw new RuntimeException("递减因子必须大于0");
        }
        return redisTemplate.opsForValue().increment(key, -delta);
    }


    // ================================Map=================================

    /**
     * HashGet
     * @param key  键 不能为null
     * @param item 项 不能为null
     */
    public static Object hget(String key, String item) {
        return redisTemplate.opsForHash().get(key, item);
    }

    /**
     * 获取hashKey对应的所有键值
     * @param key 键
     * @return 对应的多个键值
     */
    public static Map<Object, Object> hmget(String key) {
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * HashSet
     * @param key 键
     * @param map 对应多个键值
     */
    public static boolean hmset(String key, Map<String, Object> map) {
        try {
            redisTemplate.opsForHash().putAll(key, map);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * HashSet 并设置时间
     * @param key  键
     * @param map  对应多个键值
     * @param time 时间(秒)
     * @return true成功 false失败
     */
    public static boolean hmset(String key, Map<String, Object> map, long time) {
        try {
            if (time > 0) {
                redisTemplate.opsForHash().putAll(key, map);
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * @param key   键
     * @param item  项
     * @param value 值
     * @return true 成功 false失败
     */
    public static boolean hset(String key, String item, Object value) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * @param key   键
     * @param item  项
     * @param value 值
     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间
     * @return true 成功 false失败
     */
    public static boolean hset(String key, String item, Object value, long time) {
        try {
            if (time > 0) {
                redisTemplate.opsForHash().put(key, item, value);
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除hash表中的值
     *
     * @param key  键 不能为null
     * @param item 项 可以使多个 不能为null
     */
    public static void hdel(String key, Object... item) {
        redisTemplate.opsForHash().delete(key, item);
    }


    /**
     * 判断hash表中是否有该项的值
     *
     * @param key  键 不能为null
     * @param item 项 不能为null
     * @return true 存在 false不存在
     */
    public static boolean hHasKey(String key, String item) {
        return redisTemplate.opsForHash().hasKey(key, item);
    }


    /**
     * hash递增 如果不存在,就会创建一个 并把新增后的值返回
     *
     * @param key  键
     * @param item 项
     * @param by   要增加几(大于0)
     */
    public static double hincr(String key, String item, double by) {
        return redisTemplate.opsForHash().increment(key, item, by);
    }


    /**
     * hash递减
     *
     * @param key  键
     * @param item 项
     * @param by   要减少记(小于0)
     */
    public static double hdecr(String key, String item, double by) {
        return redisTemplate.opsForHash().increment(key, item, -by);
    }


    // ============================set=============================

    /**
     * 根据key获取Set中的所有值
     * @param key 键
     */
    public static Set<Object> sGet(String key) {
        try {
            return redisTemplate.opsForSet().members(key);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }


    /**
     * 根据value从一个set中查询,是否存在
     *
     * @param key   键
     * @param value 值
     * @return true 存在 false不存在
     */
    public static boolean sHasKey(String key, Object value) {
        try {
            return redisTemplate.opsForSet().isMember(key, value);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 将数据放入set缓存
     *
     * @param key    键
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public static long sSet(String key, Object... values) {
        try {
            return redisTemplate.opsForSet().add(key, values);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }


    /**
     * 将set数据放入缓存
     *
     * @param key    键
     * @param time   时间(秒)
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public static long sSetAndTime(String key, long time, Object... values) {
        try {
            Long count = (long)values.length;
            if (time > 0) {
                count = redisTemplate.opsForSet().add(key, values);
                expire(key, time);
            }
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }


    /**
     * 获取set缓存的长度
     *
     * @param key 键
     */
    public static long sGetSetSize(String key) {
        try {
            return redisTemplate.opsForSet().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }


    /**
     * 移除值为value的
     *
     * @param key    键
     * @param values 值 可以是多个
     * @return 移除的个数
     */

    public static long setRemove(String key, Object... values) {
        try {
            return redisTemplate.opsForSet().remove(key, values);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    // ===============================list=================================

    /**
     * 获取list缓存的内容
     *
     * @param key   键
     * @param start 开始
     * @param end   结束 0 到 -1代表所有值
     */
    public static List<Object> lGet(String key, long start, long end) {
        try {
            return redisTemplate.opsForList().range(key, start, end);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }


    /**
     * 获取list缓存的长度
     *
     * @param key 键
     */
    public static long lGetListSize(String key) {
        try {
            return redisTemplate.opsForList().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }


    /**
     * 通过索引 获取list中的值
     *
     * @param key   键
     * @param index 索引 index>=0时， 0 表头，1 第二个元素，依次类推；index<0时，-1，表尾，-2倒数第二个元素，依次类推
     */
    public static Object lGetIndex(String key, long index) {
        try {
            return redisTemplate.opsForList().index(key, index);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }


    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     */
    public static boolean lSet(String key, Object value) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 将list放入缓存
     * @param key   键
     * @param value 值
     * @param time  时间(秒)
     */
    public static boolean lSet(String key, Object value, long time) {
        try {
            if (time > 0) {
                redisTemplate.opsForList().rightPush(key, value);
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }

    }


    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @return true 存放成功 false存放失败
     */
    public static boolean lSet(String key, List<Object> value) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }

    }


    /**
     * 将list放入缓存
     *
     * @param key   键
     * @param value 值
     * @param time  时间(秒)
     * @return true 存放成功 false存放失败
     */
    public static boolean lSet(String key, List<Object> value, long time) {
        try {
            if (time > 0) {
                redisTemplate.opsForList().rightPushAll(key, value);
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 根据索引修改list中的某条数据
     *
     * @param key   键
     * @param index 索引
     * @param value 值
     * @return true 存放成功 false存放失败
     */

    public static boolean lUpdateIndex(String key, long index, Object value) {
        try {
            redisTemplate.opsForList().set(key, index, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }


    /**
     * 移除N个值为value
     *
     * @param key   键
     * @param count 移除多少个
     * @param value 值
     * @return 移除的个数
     */

    public static long lRemove(String key, long count, Object value) {
        try {
            return redisTemplate.opsForList().remove(key, count, value);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }
}
```



## 测试RedisUtils

```java
@Test
public void testByRedisUtils() {
    RedisUtils02.set("username", "xxx");
    System.out.println(RedisUtils02.get("username"));
}
```





# 👆 为基础， 进阶 👇





# Redis.conf配置文件

...

### save

> **[多少]s内至少有[几]个key进行了修改，就进行持久化**
>
> save 900 1
>
> save 300 10
>
> save 60 10000





### stop-writes-on-bgsave-error

> **在持久化出错的时候，停止写入**
>
> stop-writes-on-bgsave-error yes





### rdbcompression

> **是否压缩rdb文件，需要消耗一些cpu资源，如果对线上要求高，可以关掉**
>
> rdbcompression yes





### maxmemory-policy

> **maxmemory-policy** noeviction

> 1.volatile-lru(least recently used):最近最少使用算法，从设置了过期时间的键key中选择空转时间最长的键值对清除掉；
>
> 2.volatile-lfu(least frequently used):最近最不经常使用算法，从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉；
>
> 3.volatile-ttl:从设置了过期时间的键中选择过期时间最早的键值对清除；
>
> 4.volatile-random:从设置了过期时间的键中，随机选择键进行清除；
>
> 5.allkeys-lru:最近最少使用算法，从所有的键中选择空转时间最长的键值对清除；
>
> 6.allkeys-lfu:最近最不经常使用算法，从所有的键中选择某段时间之内使用频次最少的键值对清除；
>
> 7.allkeys-random:所有的键中，随机选择键进行删除；
>
> 8.noeviction:不做任何的清理工作，在redis的内存超过限制之后，所有的写入操作都会返回错误；但是读操作都能正常的进行;



### appendonly

> **默认是不开启aof模式的，默认使用的是rdb方式持久化，大部分情况下，rdb完全够用**
>
> appendonly no

> **执行sync频率**
>
> appendfsync [参数]
>
> - everysec  **每秒**
> - always	**每次修改都执行（消耗性能）**
> - no		**不执行sync，操作系统自己同步数据，速度最快**





# Redis持久化





# AOF

appendonly.aof

如果aof文件有错误，redis是无法启动的，需要修复这个aof

redis提供了修复工具：redis-check-aof，就在redis-server同级目录

`redis-check-aof --fix appendonly.aof`



# Redis发布订阅

## 订阅端

**`SUBSCRIBE [channel]`**

订阅一个频道，监听该频道发布的所有新消息，等待读取...

> **接收到的推送消息格式**
>
> "message"
>
> "[channel]"（频道名称）
>
> "[message]"（消息的具体内容）



## 发送端

**`PUBLISH [channel] "message"`**

把消息发送到一个频道





# Redis主从复制

**一台服务器模拟主从复制，启动三个redis服务：**

分别使用三个不同的配置文件



**作用：**

- 数据冗余
- 故障恢复
- 负载均衡
- 高可用（集群）基石



## 环境配置

只配置从库，不配置主库

**`info replication`**：查看当前库的信息

1. 把redis.conf复制三个，命名可以按**redis[端口].conf**
2. 端口：主库不变，从库都修改为不同的端口
3. **从库**修改profile /var/**runredis_6379.pid**为**runredis_[从库端口].pid**
4. **主库从库**都要修改**logfile为“[端口].log”**
5. **主库从库**都要修改**dbfilename dump.rdb**为**dump[端口].rdb**
6. 保存退出，配置另外三个配置文件，执行2-5步骤



把一台服务器主机开四个会话

其中三个执行从库配置文件：**`redis-server config/redis[端口].conf`**

第四个用来**查看服务启动情况：** `ps -ef|grep redis`



## 配置一主二从

**默认情况，每一台Redis服务器都是主节点**

将刚才的三台Redis服务，启动对应客户端，使用info replication命令查看，发现都是主机

一般情况下，仅配置从机即可



### 设自己为从机，认主机

#### 使用命令配置从机（暂时）

`SLAVEOF 127.0.0.1 6379`

表示 ： 当前端口（非6379）开启的redis服务，认本地端口为6379的redis服务为主机

此时再使用 `info replication` 就可以看到 role为slave从机

在主机下再次使用 `info replication` 可以看到 `connected_salaves: x`

x代表的就是**从机数量**

也可以看到从机的相关信息：

`slave[x]：ip=...，port=..，state=...,offset=...,lag=...`

> **真实的主从配置应该在配置文件中配置，这样的话才是永久的！**
>
> **使用命令配置的只是暂时的，当从机关机再次启动后，他又自动变为主机了**
>
> **此时重新变为从机，马上同步主机的所有数据与信息**



#### 使用配置文件配置从机

在redis.conf中

> #设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步
>
> `slaveof <masterip> <masterport>`
>
> #当master服务设置了密码保护时，slav服务连接master的密码
>
> `masterauth <master-password>`



## 补充

主机可以写，从机不能写，只能读

主机中的所有信息和数据，都会被从机保存

**测试高可用：** 主机断开连接，从机依旧连接到主机，但是没有写的操作，这时候如果主机回来，从机依旧可以获取主机的写操作

**目标：** 主机断了，从机中的一个变为主机



## 复制原理

Slave启动成功连接到master后会发送一个sync同步命令

Master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave,并完成一次完全同步。

**全量复制：** 而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。

**增量复制：** Master继续将新的所有收集到的修改命令依次传给slave,完成同步

但是只要是重新连接master,一次完全同步（全量复制）将被自动执行！我们的数据一定可以在从机中看到！























