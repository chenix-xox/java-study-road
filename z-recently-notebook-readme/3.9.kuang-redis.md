# 3V和3高

大数据时代的3V

- 海量Volume
- 多样Variety
- 实时Velocity



互联网需求的3高

- 高并发
- 高可拓
- 高性能





# 杂谈

[阿里云的这群疯子](https://www.huxiu.com/article/267100.html)



> - 商品基本信息
>
>   名称、价格、商家信息...
>
>   MySQL
>
> - 商品的描述、评论（文字较多）
>
>   文档型数据库，MongoDB
>
> - 图片
>
>   分布式文件系统 FastDFS
>
>   阿里云：OSS
>
>   Hadoop：HDFS
>
> - 商品关键字（搜索）
>
>   搜索引擎：solr / elasticsearch
>
>   Isearch：阿里-多隆
>
> - 商品热门的波段信息
>
>   内存数据库：Redis、Tair、Memache...
>
> - 商品交易、外部的支付接口
>
>   第三方应用



**MongoDB：**

介于关系型数据库和非关系系数据库之间，是非关系型数据库中功能最丰富，最像关系型数据库的





# 概述

**能干什么**

1. 内存存储、持久化，内存中是断电即失、所以说持久化很重要(rdb、aof)
2. 效率高，可以用于高速缓存
3. 发布订阅系统
4. 地图信息分析
5. 计时器、计数器（浏览量！）



**特性**

1. 多样的数据类型
2. 持久化
3. 集群
4. 事务
5. ...



# 安装

1. 下载redis-7.2.4.tar.gz	

2. 放到opt目录下

   ```bash
   mv redis-7.2.4.tar.gz /opt
   ```

3. 在opt目录下解压

   ```bash
   cd /tar
   tar -zxvf redis-7.2.4.tar.gz
   ```

4. 基本环境：安装gcc，执行make，执行make instal

5. 默认安装路径：`cd /usr/local/bin/`

6. 将redis配置文件复制到当前目录（redis安装目录）

7. 使用配置文件进行启动

   **Redis默认不是后台启动的，修改配置文件！**

   修改`daemonize no`为**yes**

8. 通过配置文件启动redis

   在redis的安装目录中 `redis-server cconfig/redis.conf `

   > **报错**
   >
   > WARNING Memory overcommit must be enabled! Without it, a background save or replication may fail under low memory condition. Being disabled, it can also cause failures without low memory condition, see https://github.com/jemalloc/jemalloc/issues/1328. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.

   > **解决方案**
   >
   > 在/etc/sysctl.conf中加入sysctl vm.overcommit_memory=1
   >
   > 然后重启机器or刷新
   >
   > 刷新：
   >
   > /sbin/sysctl -p 
   >
   > /sbin/sysctl -w net.ipv4.route.flush=1

9. 启动redis客户端进行连接 `redis-cli -p 6379`

10. 复制服务器会话，查看已开启的redis服务 `ps -ef | grep redis`



# Redis命令



1. ping : 测试Redis是否连接成功，连接成功返回PONG

2. set [参数名] [参数值] ： 创建键值对

3. get [参数名] ： 根据键查看值

4. keys * : 查看所有已存在的值

5. shutdown ： 关闭redis服务

6. exit ： 退出

7. select [序号] ： 切换到指定数据库

8. DBSIZE ： 查看数据库大小

9. flushdb ： 清空当前数据库的所有键值对

10. flushall ： 清空全部数据库的键值对

11. exists [参数名] : 查询某个参数是否存在（返回 1/0 ）

12. move [参数名] [数据库序号] : 移动参数到指定数据库（好像如果是当前数据库的话，就会产生移除效果）

13. expire [参数名] [多少秒] : 设置某个参数多少秒过期

14. ttl [参数名] ： 查看参数剩余过期时间

15. del [参数名] ： 删除参数

16. type [参数名] ： 查看参数数据类型

17. **###########   Sring👇   #############**

18. append [参数名] [参数值] ： 在指定参数后面加上对应参数值（如果该参数不存在，此命令等于set key）

19. strlen [参数名] ： 获取字符串长度

20. getrange [参数名] [起始位置] [结束位置] ： 获取参数起始位置到结束位置的值（ **ps：**获取从头到尾，可以设置0,-1）

21. setrange [参数名] [起始位置] [替换值] : 将指定参数，从指定起始位置，开始替换，替换为 指定替换值

22. **################   做 ++ 操作（浏览量，点击量...） 👇 ##################**

23. > set views 0; // 创建浏览量参数
    >
    > incr views; // 开始++
    >
    > decr views; // 开始--
    >
    > incrby views [步长]; // 根据步长开始++，例如步长为10，直接+10
    >
    > decrby views [步长]; // 根据步长开始--，例如步长为10，直接-10

24.  **######################   ..其他.. 👇  ###########################**

25. setex [参数名] [过期时间] [参数值] ： 带着参数时间建立参数

26. **setnx [参数名] [参数值]** ： **<u>（在分布式锁中会常常使用！）</u>**如果参数名不存在，则创建对应参数，如果存在，则不继续进行创建

27. mset [参数名1] [参数值1] [参数名2] [参数值2] ... ： 批量创建参数

28. mget [参数名1] [参数名2] [参数名3] ... ： 批量获取参数

29. msetnx [参数名1] [参数值1] [参数名2] [参数值2] ... ： 批量创建参数(如果参数名不存在，则创建...)

30. > **使用mset创建json数据**
    >
    > mset user:1:name zhangsan user:1:age 2
    >
    > mget user:1:name user:1:age
    >
    > **格式：**user:{id}:{filed}
    >
    > 例如：设置第1000篇文章的浏览量
    >
    > set article:1000:views 0;

31. getset [参数名] [参数值] ： 先获取，再创建

    > 例如，创建一个不存在的参数，使用 getset db redis;
    >
    > 会返回一个 (nil) 不存在，但是已经创建好了db参数
    >
    > 此时，再次使用 getset db mongodb
    >
    > 将返回 redis，并覆盖为mongodb

32. **################   List 👇   ##################**

33. LPUSH/RPUSH [参数名] [参数值] : 可以不断往同一个参数名中放入值（L代表的是从左边开始放值，R是从右边开始放值）

34. LRANGE [参数名] [起始位置] [结束位置] ： 查询list，如果查询全部，直接 `LRANGE xxx 0 -1`

35. LPOP/RPOP [参数名] ： 移除一个值（ L / R 左或右 ）

36. LINDEX [参数名] [下标] ： 通过下标获取值

37. LLEN [参数名] ： 返回列表的长度

38. LREM [参数名] [COUNT] [参数值] ： 移除指定参数中的指定值，移除COUNT个

39. LTRIM [参数名] [起始位置] [结束位置] ： 只留下指定位置到指定位置的内容

40. RPOPLPUSH [参数1] [参数2] ： 移除参数1的最后一个值，并插入到参数2（被移除的值插入到参数2） 

41. LSET [参数名] [下标] [参数值] ： 将指定参数的，指定下标的内容替换为新的参数值

42. LINSERT [参数名] [位置（before/after）] [哪个值] [参数值] ： 在指定**参数名**的**before/after**的位置，**指定某个值**添加**参数值**

43. **################   Hash   👇 ################**

44. HSET [参数名] [key] [value] ： 创建参数，值为 <u>Map键值对</u>

45. HGET [参数名] [key] ： 指定参数名，获取指定key的value

46. HMSET [参数名] [key1] [value1] [key2] [value2] [key3] [value3] : 批量创建Map键值对

47. HMGET [参数名] [key1] [key2] ： 批量获取指定key的value

    > Redis4.0开始，弃用HMSET，直接使用HSET也可以批量创建

48. HGETALL [参数名] ： 获取一个指定参数中的**所有键值对**

    > **顺着以**
    >
    > key1
    >
    > value1
    >
    > key2
    >
    > value2
    >
    > **显示**

49. HDEL [参数名] [key1] [key2] ： 删除指定参数的指定key

50. HLEN [参数名] : 查看key-value个数

51. HEXISTS [参数名] [key] ： 判断指定参数名中的指定key是否存在

52. HKEYS [参数名] ： 获取指定参数名中的**所有key**

53. HVALS [参数名] ： 获取指定参数名中的**所有value**

54. HINCRBY [参数名] [key] [数值] ： 给指定参数名的 指定key 的value 增加或减少 一个值

55. HSETNX [参数名] [key] [value] ： 不存在则添加成功，存在则添加失败

56. **#######################   Zser  👇 #########################**

57. zadd [参数名] [序号位置] [参数值] ： 给指定参数添加指定参数值，并配上其序号位置，作为排序依据【这个排序依据，称为Score】

58. zrange [参数名] [起始位置] [结束位置] ： 查看有序集合

    **PS：**还有ZREVRANGE

59. zrangebyscore [参数名] [min] [max] ： 将指定参数名，通过SCORE，进行范围查看，从指定的min值，到指定的max值查看

    **PS**：使用ZREVRANGEBYSCORE，可以从max到min进行查看【逆序】  

    > **例如**
    >
    > ZRANGEBYSCORE xxx -inf +inf	：表示从负无穷到正无穷排序，就是从小到大排序
    >
    > ZRANGEBYSCORE xxx -inf 2500	：表示从负无穷到最大2500排序

60. zrangebyscore [参数名] [min] [max] WITHSCORES ： 如上，会带上SCORE内容

    > **查询结果，如下：**
    >
    > "value1"
    >
    > "score1"
    >
    > "value2"
    >
    > "score2"
    >
    > ...

61. ZCARD [参数名] ： 查看指定参数名的元素个数 

62. ZCOUNT [参数名] [起始位置] [结束位置] ： 获取起始位置到结束位置中间值的个数 













# 测试性能

`redis-benchmark`：压力测试工具

官方自带的性能测试工具

| 序号 | 选项               | 描述                                       | 默认值    |
| ---- | ------------------ | ------------------------------------------ | --------- |
| 1    | -h                 | 指定服务器主机名                           | 127.0.0.1 |
| 2    | -p                 | 指定服务器端口                             | 6379      |
| 3    | -s                 | 指定服务器 socket                          |           |
| 4    | -c                 | 指定并发连接数                             | 50        |
| 5    | -n                 | 指定请求数                                 | 10000     |
| 6    | -d                 | 以字节的形式指定 SET/GET 值的数据大小      | 2         |
| 7    | -k                 | 1=keep alive 0=reconnect                   | 1         |
| 8    | -r                 | SET/GET/INCR 使用随机 key, SADD 使用随机值 |           |
| 9    | -P                 | 通过管道传输 <numreq> 请求                 | 1         |
| 10   | -q                 | 强制退出 redis。仅显示 query/sec 值        |           |
| 11   | --csv              | 以 CSV 格式输出                            |           |
| 12   | -l（L 的小写字母） | 生成循环，永久执行测试                     |           |
| 13   | -t                 | 仅运行以逗号分隔的测试命令列表。           |           |
| 14   | -I（i 的大写字母） | Idle 模式。仅打开 N 个 idle 连接并等待。   |           |

**例如：**测试 100个并发连接 ， 100000个请求

`redis-benchmark -h localhost -p 6379 -c 100 -n 100000`

测试结果字段解释 —— SET部分：

> ====== SET ======                          
>
>  100000 requests completed in 0.82 seconds
>
>  100 parallel clients	：	**100个并发客户端**
>
>  3 bytes payload	：	**每次写入3个字节**
>
>  keep alive: 1	：	**只有一台服务器来处理这些请求，单机性能**
>
>  host configuration "save": 3600 1 300 100 60 10000
>
>  host configuration "appendonly": no
>
>  multi-thread: no
>
> throughput summary: 140845.08 requests per second	：	**每秒处理140845.08个请求**
>



# 基础知识

默认16个数据库，在redis.conf中

`databases 16`

默认使用第0个，可以是用select进行切换数据库（见Redis命令第6个）









# 五大数据类型

> - Redis-Key
> - String
> - List
> - Set（集合）
> - Hash（散列）
> - Zset

## String

**常用如下**

1. append [参数名] [参数值] ： 在指定参数后面加上对应参数值（如果该参数不存在，此命令等于set key）

2. strlen [参数名] ： 获取字符串长度

3. getrange [参数名] [起始位置] [结束位置] ： 获取参数起始位置到结束位置的值（ **ps：**获取从头到尾，可以设置0,-1）

4. setrange [参数名] [起始位置] [替换值] : 将指定参数，从指定起始位置，开始替换，替换为 指定替换值

5. > set views 0; // 创建浏览量参数
   >
   > incr views; // 开始++
   >
   > decr views; // 开始--
   >
   > incrby views [步长]; // 根据步长开始++，例如步长为10，直接+10
   >
   > decrby views [步长]; // 根据步长开始--，例如步长为10，直接-10

6. setex [参数名] [过期时间] [参数值] ： 带着参数时间建立参数

7. **setnx [参数名] [参数值]** ： **<u>（在分布式锁中会常常使用！）</u>**如果参数名不存在，则创建对应参数，如果存在，则不继续进行创建

8. mset [参数名1] [参数值1] [参数名2] [参数值2] ... ： 批量创建参数

9. mget [参数名1] [参数名2] [参数名3] ... ： 批量获取参数

10. msetnx [参数名1] [参数值1] [参数名2] [参数值2] ... ： 批量创建参数(如果参数名不存在，则创建...)

11. > **使用mset创建json数据**
    >
    > mset user:1:name zhangsan user:1:age 2
    >
    > mget user:1:name user:1:age
    >
    > **格式：**user:{id}:{filed}
    >
    > 例如：设置第1000篇文章的浏览量
    >
    > set article:1000:views 0;

12. getset [参数名] [参数值] ： 先获取，再创建

    > 例如，创建一个不存在的参数，使用 getset db redis;
    >
    > 会返回一个 (nil) 不存在，但是已经创建好了db参数
    >
    > 此时，再次使用 getset db mongodb
    >
    > 将返回 redis，并覆盖为mongodb







## List

list可以玩成 栈、队列、阻塞队列！

栈：先进后出

队列：先进先出

阻塞队列：两边都开？

**所有的list命令都是以l开头**

1. LPUSH/RPUSH [参数名] [参数值] : 可以不断往同一个参数名中放入值（L代表的是从左边开始放值，R是从右边开始放值）
2. LRANGE [参数名] [起始位置] [结束位置] ： 查询list，如果查询全部，直接 `LRANGE xxx 0 -1`
3. LPOP/RPOP [参数名] ： 移除一个值（ L / R 左或右 ）
4. LINDEX [参数名] [下标] ： 通过下标获取值
5. LLEN [参数名] ： 返回列表的长度
6. LREM [参数名] [COUNT] [参数值] ： 移除指定参数中的指定值，移除COUNT个
7. LTRIM [参数名] [起始位置] [结束位置] ： 只留下指定位置到指定位置的内容
8. RPOPLPUSH [参数1] [参数2] ： 移除参数1的最后一个值，并插入到参数2（被移除的值插入到参数2） 
9. LSET [参数名] [下标] [参数值] ： 将指定参数的，指定下标的内容替换为新的参数值
10. LINSERT [参数名] [位置（before/after）] [哪个值] [参数值] ： 在指定**参数名**的**before/after**的位置，**指定某个值**添加**参数值**







## Set（集合）

set中的值不能重复！

1. SADD [参数名] [参数值] : 添加集合元素
2. SMEMBERS [参数名] : 查看集合元素
3. SISMEMBER [参数名] [参数值] ： 查看指定参数名，是否存在指定参数，返回 1 / 0
4. SCARD [参数名] ： 查看集合中的元素个数
5. SREM [参数名] [参数值] ： 移除指定参数名中的指定参数值
6. SRANDMEMBER [参数名] [个数]： 从指定参数名中取出随机参数值，可以不写数量值，默认一个
7. SPOP [参数名] ： 从指定参数名的集合中随机取出元素
8. SMOVE [参数名1] [参数名2] [参数值] ： 将指定参数名1内的指定参数值，移动到参数名2
9. SDIFF [参数名1] [参数名2] ： 查看参数名1中，参数名2没有的元素（差集）
10. SINTER [参数名1] [参数名2] ： 查看参数名1和参数名2中的共同元素（交集）（共同好友）
11. SUNION [参数名1] [参数名2] ： 查看参数名1和参数名2加起来的所有元素【去重】（并集）





## Hash（哈希）

1. HSET [参数名] [key] [value] ： 创建参数，值为 <u>Map键值对</u>

2. HGET [参数名] [key] ： 指定参数名，获取指定key的value

3. HMSET [参数名] [key1] [value1] [key2] [value2] [key3] [value3] : 批量创建Map键值对

4. HMGET [参数名] [key1] [key2] ： 批量获取指定key的value

   > Redis4.0开始，弃用HMSET，直接使用HSET也可以批量创建

5. HGETALL [参数名] ： 获取一个指定参数中的**所有键值对**

   > **顺着以**
   >
   > key1
   >
   > value1
   >
   > key2
   >
   > value2
   >
   > **显示**

6. HDEL [参数名] [key1] [key2] ： 删除指定参数的指定key

7. HLEN [参数名] : 查看key-value个数

8. HEXISTS [参数名] [key] ： 判断指定参数名中的指定key是否存在

9. HKEYS [参数名] ： 获取指定参数名中的**所有key**

10. HVALS [参数名] ： 获取指定参数名中的**所有value**

11. HINCRBY [参数名] [key] [数值] ： 给指定参数名的 指定key 的value 增加或减少 一个值

12. HSETNX [参数名] [key] [value] ： 不存在则添加成功，存在则添加失败

 





## Zset（有序集合）

1. zadd [参数名] [序号位置] [参数值] ： 给指定参数添加指定参数值，并配上其序号位置，作为排序依据【这个排序依据，称为Score】

2. zrange [参数名] [起始位置] [结束位置] ： 查看有序集合

   **PS：**还有ZREVRANGE

3. zrangebyscore [参数名] [min] [max] ： 将指定参数名，通过SCORE，进行范围查看，从指定的min值，到指定的max值查看

   **PS**：使用ZREVRANGEBYSCORE，可以从max到min进行查看【逆序】  

   > **例如**
   >
   > ZRANGEBYSCORE xxx -inf +inf	：表示从负无穷到正无穷排序，就是从小到大排序
   >
   > ZRANGEBYSCORE xxx -inf 2500	：表示从负无穷到最大2500排序

4. zrangebyscore [参数名] [min] [max] WITHSCORES ： 如上，会带上SCORE内容

   > **查询结果，如下：**
   >
   > "value1"
   >
   > "score1"
   >
   > "value2"
   >
   > "score2"
   >
   > ...

5. ZCARD [参数名] ： 查看指定参数名的元素个数 

6. ZCOUNT [参数名] [起始位置] [结束位置] ： 获取起始位置到结束位置中间值的个数 







# 三种特殊数据类型



> - geospatial
> - hyperloglog
> - bitmaps

## geospatial地理位置

> Redis的Geo阿紫Redis3.2推出，可以推算地理位置信息，两地之间的距离，方圆几里的人

### GEOADD

添加地理位置

> **规则：**地球两极无法直接添加
>
> 一般会下载城市的数据，通过Java程序一次性导入

**格式：**`geoadd [参数1]:[参数2] [经度] [纬度] [城市名]`

> **例如：** geoadd china:city 121.47 31.23 shanghai
>
> **表示：** 添加 **中国:城市 / 经纬度 / 上海**

也可以一次性添加多个！

`geoadd china:city 121.47 31.23 shanghai 116.41 39.90 beijing`



### GEOPOS

查询地理位置

**格式：**`GEOPOS [参数1]:[参数2] [城市名]`

> **例如：**GEOPOS china:city beijing
>
> **表示：**查询**北京**的经纬度坐标

也可以一次性获取多个！

`GEOPOS china:city beijing wuhan`



### GEODIST

返回两个给定位置之间的距离

> **单位：**
>
> - m：米
> - km：千米
> - mi：英里
> - ft：英尺

**格式：**`GEODIST [参数1]:[参数2] [位置1] [位置2] [单位]`

> **例如：**GEODIST china:city beijing shanghai KM
>
> **表示：**计算北京和上海的直线距离，单位km



### GEORADIUS

以给定的经纬度为中心，找出某一半径的元素

**格式：**`GEORADIUS [参数1]:[参数2] [经度] [纬度] [距离] [单位]`

> **例子：**GEORADIUS china:city 116.41 39.9 10000 km
>
> **表示：**查询116.41 39.9 ，周围10000km以内的地点（从china:city）中

> **加在末尾的其他参数，返回附加信息：**
>
> - `WITHDIST`：也返回从指定中心点返回的项目的距离。距离以与命令的半径参数指定的单位相同的单位返回。
>
> - `WITHCOORD`: 也返回匹配项目的经度和纬度坐标。
>
> - `WITHHASH`：也返回项目的原始地理哈希编码排序集分数，以52位无符号整数的形式返回。这仅对低级别的黑客或调试有用，对普通用户来说没有太大兴趣。
>
>   
>
> **默认情况下，命令将返回未排序的项目。可以使用以下两个选项调用两种不同的排序方法：**
>
> - `ASC`：根据与中心点的距离，将返回的项目从最近到最远排序。
> - `DESC`：根据与中心点的距离，将返回的项目从最远到最近排序。
>
> 默认情况下，将返回所有匹配的项目。可以通过使用 **COUNT `<count>`** 选项将结果限制为前N个匹配的项目。 当提供了 `ANY` 时，命令会在找到足够的匹配项后立即返回， 因此结果可能不是离指定点最近的结果，但是服务器的投入量显著较低。 当未提供 `ANY` 时，命令将根据与指定区域匹配的项目数量进行排序并执行相应的操作， 因此，即使只返回了少量结果，在查询非常大的区域和非常小的 `COUNT` 选项时可能会很慢。



### GEORADIUSBYMEMBER

根据已有元素，查询其周围元素

格式：`GEORADIUSBYMEMBER [参数1]:[参数2] [城市名] [距离] [单位]`

> **例子：**GEORADIUSBYMEMBER china:city beijing 10000 km
>
> **表示：**查询北京周围10000km的元素





### GEOHASH

返回指定元素的Geohash字符串

**格式：**`GEOHASH [参数1]:[参数2] [城市名1] [城市名2]`

> **例子：**GEOHASH china:city beijing shanghai
>
> **表示：**返回北京和上海的geohash字符串，结果如下 👇
>
> 1) "wx4fbzx4me0"
> 2) "wtw3sj5zbj0"



### 注意

GEO底层实现原理就是Zset，因此可以使用Zset来操作Geo



## Hyperloglog

> 什么是基数？

A{1,3,5,7,8,7}

B{1,3,5,7,8}

基数，即一个集合中不重复的元素

上面的基数 = 5



### 简介

[HyperLogLog | Redis 中文网 (redisdocs.com)](https://www.redisdocs.com/zh-cn/docs/data-types/probabilistic/hyperloglogs/)

基数统计的算法，有0.81%的容错，允许容错的场景可以使用！

HyperLogLog是一种概率数据结构，用于估算一个集合的基数。



**应用场景：**网页UV（一个人访问一个网站多次，但是依旧算作一个人）

> **传统的方式：**set保存用户的id，set存储的是不重复元素，统计set中的元素数量作为判断标准
>
> **缺点：**保存大量用户id，很麻烦；目的是为了计数，而不是保存用户id；很占内存！

使用Hyperloglog，占内存是固定的，2^64个不同的元素的基数，仅12kb



### PFADD

将元素都添加到指定的一个参数中

**格式：**`PFADD [参数名] [参数值1] [参数值2] [参数值3] ...`

将参数值1~参数值3...，全部添加到这个参数名中



### PFCOUNT

统计指定参数的元素数量

**格式：**`PFCOUNT [参数名]`



### PFMERGE

将多个参数合并成一个新的参数

**格式：**`PFMERGE [新参数名] [旧参数名1] [旧参数名2] ...`





## Bitmaps

> 位存储

统计用户信息，活跃/不活跃；登录/不登陆；签到/不签到；

类似以上，只有两种状态的，都可以使用Bitmaps

Bitmaps位图，数据结构，都是使用二进制来进行记录，只有0和1两种状态



### SETBIT

创建位图

**格式：**setbit [参数] [key] [0/1]

> **key可以为任意数值，例如记录一年的打卡数据，就可以如下 👇：**
>
> - setbit sign 0 1
> - setbit sign 1 1
> - setbit sign 2 0





### GETBIT

获取位图

**格式：**getbit [参数] [key]

获取指定key的0/1





### BITCOUNT

统计位图中1的数量

**格式：**BITCOUNT [参数]

统计指定参数中，1的数量





# 事务



## Redis的事务

### 开启并执行事务

> - 开启事务（multi）
>
> - 命令入队
>
>   ```bash
>   set xxx xxx;
>   get xxx xxx;
>   set xxx xxx;
>   set xxx xxx;
>   ```
>
> - 执行事务（exec）



### 开启却取消事务

- 开启事务（multi）

- 命令入队

  ```bash
  set xxx xxx;
  get xxx xxx;
  set xxx xxx;
  set xxx xxx;
  ```

- 放弃事务（discard）



### 异常

- **【编译型异常】**开启事务，添加命令到事务队列的过程中，出现错误（如：语法错误），那么执行事务会报错，会执行失败
- **【运行时异常】**开启事务，添加命令到事务队列中，执行事务，中途出现错误的命令，会执行失败，不影响其他事务进行





## 监视事务 👇

> **监视器:**Watch

- **悲观锁：**很悲观，认为什么时候都会出问题，无论做什么都会加锁（影响性能）

- **乐观锁：**很乐观，认为什么时候都不会出问题，所以不会上锁

  更新数据的时候去判断一下，在此期间是否有人修改过这个数据

  > 获取version
  >
  > 更新的时候比较version



### 监视举例

```bash
set money 100
set out 0
watch money     # 监视 money 对象

multi            # 开启事务
DECRYBY money 20
INCRYBY out 20
exec			# 执行事务

#正常执行成功
```



### 模拟多线程实现乐观锁

> **客户端1：money减少20，花费增加20**
>
> ```bash
> watch money		# 开启监视 money
> multi            # 开启事务
> DECRYBY money 20
> INCRYBY out 20
> ```

**情况为：客户端1 👆 还没有执行线程， 客户端2 👇 把内容修改了！**

> **客户端2：改变money为1000**
>
> ```bash
> set money 1000;
> ```

此时，客户端1 执行事务，会执行失败（执行前，另一个客户端修改了被监视的内容），直接返回（nil）

此时就相当于使用Redis实现了乐观锁操作！



### After 乐观锁监视失败

> - 解锁，类似Mysql中放弃原来的version，获取新的version
>
>   **unwatch**
>
> 
>
> - 重新监视，拿到最新的值 
>
>   **watch money**





# Jedis

> **Jedis是Redis官方推荐的Java连接开发工具**

## 导包

```xml
<!-- https://mvnrepository.com/artifact/com.alibaba.fastjson2/fastjson2 -->
<dependency>
    <groupId>com.alibaba.fastjson2</groupId>
    <artifactId>fastjson2</artifactId>
    <version>2.0.47</version>
</dependency>

<!-- https://mvnrepository.com/artifact/redis.clients/jedis -->
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>5.1.0</version>
</dependency>
```



## 使用PING测试

```java
// 1. 新建Jedis对象
Jedis jedis = new Jedis("127.0.0.1",6379);
System.out.println(jedis.ping());

// 输出PONG，测试成功！
```



## Redis设置密码

**设置密码：**`config set requirepass [password]`

**查看密码：**`config get requirepass`



## Jedis连接键入密码

```java
jedis.auth("[password]");
```



## Jedis测试代码

```java
Jedis jedis = new Jedis("127.0.0.1", 6379);
jedis.auth("pwd");
System.out.println(jedis.ping());

System.out.println("清空数据：" + jedis.flushDB());
System.out.println("判断某个键是否存在：" + jedis.exists("username"));
System.out.println("新增<'username','xxx'>的键值对：" + jedis.set("username", "xxx"));
System.out.println("新增<'password','password'>的键值对：" + jedis.set("password", "pwd"));
System.out.print("系统中所有的键如下：");
Set<String> keys = jedis.keys("*");
System.out.println(keys);
System.out.println("password:" + jedis.del("password"));
System.out.println("判断键password,是否存在：" + jedis.exists("password"));
System.out.println("查看键username所存储的值的类型：" + jedis.type("username"));
System.out.println("随机返回key空间的一个：" + jedis.randomKey());
System.out.println("key:" + jedis.rename("username", "name"));
System.out.println("取出改后的name:" + jedis.get("name"));
System.out.println("按索引查询：" + jedis.select(0));
System.out.println("查看当前数据库中key的数目：" + jedis.dbSize());
System.out.println("查看当前数据库中所有的key：" + jedis.keys("*"));
System.out.println("删除当前选择数据库中的所有key:" + jedis.flushDB());
System.out.println("返回当前数据库中key的数目：" + jedis.dbSize());
System.out.println("删除所有数据库中的所有key:" + jedis.flushAll());

jedis.close();
```



## Jedis事务测试代码

> 事务执行失败，直接catch异常并关闭事务

```java
Jedis jedis = new Jedis("127.0.0.1", 6379);
jedis.auth("pwd");

// 添加测试数据
JSONObject jsonObject = new JSONObject();
jsonObject.put("username", "xxx");
jsonObject.put("password", "pwd");
String result = jsonObject.toString();

// 清空数据库
jedis.flushDB();

// 开启事务
Transaction multi = jedis.multi();
try {
    multi.set("user1", result);
    multi.set("user2", result);
    int i = 1 / 0;
    multi.exec();
} catch (Exception e) {
    // 执行失败，关闭事务
    multi.discard();
    e.printStackTrace();
} finally {
    // 执行成功，打印值
    System.out.println(jedis.get("user1"));
    System.out.println(jedis.get("user2"));

    // 关闭redis连接
    jedis.close();
}
```





# SpringBoot整合Redis

> **前言：**
>
> SpringBoot2.x之后，原来使用的jedis被替换为了lettuce
>
> **jedis：**采用的直连，多个线程操作是不安全的，想要避免不安全，需要使用jedis pool连接池（更像BIO模式）
>
> **lettuce：**底层采用netty，实例可以在多个线程中共享，不存在线程不安全的情况（更像NIO模式）

































